<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>历史详情</title>
  <!-- KaTeX 公式渲染样式 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsmind/style/jsmind.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <link rel="stylesheet" href="../../css/history_detail.css">
  <link rel="stylesheet" href="../../css/history_detail_inline_styles.css">

</head>
<body>
  <!-- NEW DOCK STRUCTURE -->
  <div id="bottom-left-dock">
    <div id="dock-info-stack">
      <div class="dock-column dock-labels-column">
        <div class="dock-stat-item-wrapper-progress">阅读进度:</div>
        <div class="dock-stat-item-wrapper-highlight"><span class="stat-item-clickable" data-stat-type="highlight">高亮: <span id="highlight-count">0</span></span></div>
        <div class="dock-stat-item-wrapper-img">图片: <span id="image-count">0</span></div>
        <div class="dock-stat-item-wrapper-formula">公式: <span id="formula-count">0</span></div>
      </div>
      <div class="dock-column dock-values-column">
        <div class="dock-stat-item-wrapper-progress"><span id="reading-progress-percentage-verbose">0</span>%</div>
        <div class="dock-stat-item-wrapper-annotation"><span class="stat-item-clickable" data-stat-type="annotation">批注: <span id="annotation-count">0</span></span></div>
        <div class="dock-stat-item-wrapper-tbl">表格: <span id="table-count">0</span></div>
        <div class="dock-stat-item-wrapper-words">总字数: <span id="total-word-count">0</span></div>
      </div>
    </div>
    <span id="dock-collapsed-progress-display"><span id="reading-progress-percentage">0</span>%</span>
    <a href="#" id="settings-link" title="设置"><i class="fa fa-cog"></i></a>
    <a href="#" id="dock-toggle-btn" title="折叠"><i class="fa fa-chevron-down"></i></a>
  </div>

  <!-- ===================== -->
  <!-- 浮动TOC目录按钮及悬浮窗 -->
  <!-- ===================== -->
  <div id="toc-float-btn"><i class="fa fa-list"></i></div>
  <div id="toc-popup" class="toc-popup-hidden">
    <div id="toc-popup-header">
      <span><i class="fa fa-list"></i>目录 / TOC</span>
      <button id="toc-popup-close-btn">关闭</button>
    </div>
    <ul id="toc-list"></ul>
  </div>

  <!-- ===================== -->
  <!-- 主内容容器 -->
  <!-- ===================== -->
  <div class="container">
    <h2 id="fileName">历史详情</h2>
    <div class="meta" id="fileMeta"></div>

    <!-- 标签页导航 -->
    <div class="tabs-container">
      <button class="tab-btn" id="tab-ocr">仅OCR</button>
      <button class="tab-btn" id="tab-translation">仅翻译</button>
      <!-- <button class="tab-btn" id="tab-compare">对比</button> -->
      <button class="tab-btn" id="tab-chunk-compare">分块对比</button>
    </div>
    <!-- 标签页内容显示区域 -->
    <div class="tab-content" id="tabContent"></div>
  </div>

  <!-- ===================== -->
  <!-- 自定义上下文菜单 -->
  <!-- ===================== -->
  <div id="custom-context-menu" class="context-menu-hidden">
    <ul>
      <li data-action="highlight-block">
        高亮此区块
        <div class="color-palette">
          <span class="color-option color-yellow" data-color="yellow" title="黄色"></span>
          <span class="color-option color-pink" data-color="pink" title="粉色"></span>
          <span class="color-option color-lightblue" data-color="lightblue" title="浅蓝色"></span>
          <span class="color-option color-lightgreen" data-color="lightgreen" title="浅绿色"></span>
          <span class="color-option color-purple" data-color="purple" title="紫色"></span>
          <span class="color-option color-orange" data-color="orange" title="橙色"></span>
        </div>
      </li>
      <li data-action="remove-highlight" id="remove-highlight-option" style="display: none;">取消高亮</li>
      <hr class="menu-divider" id="highlight-actions-divider" style="display: none;">
      <li data-action="add-note" id="add-note-option" style="display: none;">添加批注</li>
      <li data-action="edit-note" id="edit-note-option" style="display: none;">编辑批注</li>
      <hr class="menu-divider" id="note-actions-divider" style="display: none;">
      <li data-action="copy-content" id="copy-content-option"><i class="fa fa-copy"></i>复制内容</li>
      <!-- 更多操作可以后续添加 -->
    </ul>
  </div>

  <!-- Dock Settings Modal -->
  <div id="dock-settings-modal" class="dock-settings-modal modal-overlay"> <!-- Default: not visible -->
    <div class="dock-settings-modal-content modal-content"> <!-- ADDED modal-content class -->
      <span class="dock-settings-modal-close-btn" id="dock-settings-close-btn">&times;</span>
      <h2>显示设置</h2>
      <div class="checkbox-container"> <!-- Container for checkboxes -->
        <div class="checkbox-group">
          <input type="checkbox" id="ds-readingProgress" data-config-key="readingProgress">
          <label for="ds-readingProgress">阅读进度</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-highlights" data-config-key="highlights">
          <label for="ds-highlights">高亮</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-annotations" data-config-key="annotations">
          <label for="ds-annotations">批注</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-images" data-config-key="images">
          <label for="ds-images">图片</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-tables" data-config-key="tables">
          <label for="ds-tables">表格</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-formulas" data-config-key="formulas">
          <label for="ds-formulas">公式</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-words" data-config-key="words">
          <label for="ds-words">总字数</label>
        </div>
      </div>

      <!-- 新增TOC显示模式设置部分 -->
      <h3>目录(TOC)设置</h3>
      <div class="radio-container">
        <div class="radio-group">
          <input type="radio" id="toc-mode-both" name="toc-mode" value="both" checked>
          <label for="toc-mode-both">双语目录</label>
        </div>
        <div class="radio-group">
          <input type="radio" id="toc-mode-ocr" name="toc-mode" value="ocr">
          <label for="toc-mode-ocr">仅原文目录</label>
        </div>
        <div class="radio-group">
          <input type="radio" id="toc-mode-translation" name="toc-mode" value="translation">
          <label for="toc-mode-translation">仅译文目录</label>
        </div>
      </div>

      <div class="dock-settings-modal-buttons">
        <button id="dock-settings-save-btn" class="btn btn-primary">保存</button>
        <button id="dock-settings-cancel-btn" class="btn btn-secondary">取消</button>
      </div>
    </div>
  </div>

  <!-- Annotations/Highlights Summary Modal -->
  <div id="annotations-summary-modal" class="modal-overlay"> <!-- Default: not visible via CSS -->
    <div class="modal-content">
      <span class="modal-close-btn" id="annotations-summary-close-btn">&times;</span>
      <h2 id="annotations-summary-title">批注与高亮详情</h2>
      <div class="annotations-summary-controls">
        <label for="annotations-filter-type">类型:</label>
        <select id="annotations-filter-type">
          <option value="all">全部</option>
          <option value="highlighting">仅高亮</option>
          <option value="commenting">带批注</option>
        </select>
        <label for="annotations-filter-content">内容来源:</label>
        <select id="annotations-filter-content">
          <option value="all">全部 (OCR/翻译)</option>
          <option value="ocr">仅 OCR</option>
          <option value="translation">仅翻译</option>
        </select>
        <div class="annotations-summary-color-filter" id="annotations-summary-color-filter">
          <!-- 动态插入颜色多选 -->
        </div>
      </div>
      <div class="table-container">
        <table id="annotations-summary-table">
          <thead>
            <tr>
              <th>类型</th>
              <th>来源</th>
              <th>标识符</th>
              <th>文本片段 (预览)</th>
              <th>笔记</th>
              <th>颜色</th>
              <th>操作</th>
            </tr>
          </thead>
          <tbody id="annotations-summary-table-body">
            <!-- Rows will be populated by JavaScript -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- ===================== -->
  <!-- 依赖的JS库 -->
  <!-- ===================== -->
  <script src="../../js/storage/storage.js"></script>
  <script src="../../js/annotations/annotation_logic.js"></script>       <!-- Defines helpers like checkIfTextIsHighlighted -->
  <script src="../../js/annotations/custom_markdown_renderer.js"></script> <!-- Defines createCustomMarkdownRenderer -->
  <script src="../../js/annotations/annotation_highlighter.js"></script>   <!-- Defines applyPreprocessedAnnotations, uses helpers from annotation_logic.js -->
  <script src="../../js/ui/toc_logic.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2pdf.js@0.10.1/dist/html2pdf.bundle.min.js"></script>
  <script src="../../js/mindmap.js"></script>

  <script src="../../js/chatbot/utils/mermaid-loader.js"></script>
  <script src="../../js/chatbot/utils/markdown-katex-render.js"></script>
  <script src="../../js/chatbot/prompt/prompt-constructor.js"></script> <!-- Add this line -->
  <script src="../../js/chatbot/utils/chatbot-utils.js"></script>
  <script src="../../js/chatbot/prompt/chatbot-preset.js"></script>
  <script src="../../js/chatbot/utils/chatbot-image-utils.js"></script> <!-- Moved up to be with other utils -->
  <script src="../../js/chatbot/utils/chatbot-rendering-utils.js"></script> <!-- NEW -->
  <script src="../../js/chatbot/actions/chatbot-actions.js"></script> <!-- NEW -->
  <script src="../../js/chatbot/ui/chatbot-message-renderer.js"></script> <!-- NEW -->
  <script src="../../js/chatbot/core/chatbot-core.js"></script>
  <script src="../../js/chatbot/renderers/chatbot-mermaid-renderer.js"></script>
  <script src="../../js/chatbot/renderers/chatbot-mindmap-renderer.js"></script>
  <script src="../../js/chatbot/ui/chatbot-preset-questions-ui.js"></script>
  <script src="../../js/chatbot/ui/chatbot-floating-options.js"></script> <!-- 新增引用 -->
  <script src="../../js/chatbot/ui/chatbot-ui.js"></script>
  <script src="../../js/chatbot/ui/chatbot-model-selector-ui.js"></script>
  <script src="../../js/chatbot/core/chatbot.js"></script>
  <script src="../../js/chatbot/strategy/segmentation-strategy.js"></script>
  <script src="../../js/chatbot/chatbot-utils.js"></script>
  <script src="../../js/chatbot/chatbot-preset.js"></script>
  <script src="../../js/chatbot/chatbot-image-utils.js"></script> <!-- Moved up to be with other utils -->
  <script src="../../js/chatbot/chatbot-rendering-utils.js"></script> <!-- NEW -->
  <script src="../../js/chatbot/chatbot-actions.js"></script> <!-- NEW -->
  <script src="../../js/chatbot/chatbot-message-renderer.js"></script> <!-- NEW -->
  <script src="../../js/chatbot/chatbot-core.js"></script>
  <script src="../../js/chatbot/chatbot-mermaid-renderer.js"></script>
  <script src="../../js/chatbot/chatbot-mindmap-renderer.js"></script>
  <script src="../../js/chatbot/ui/chatbot-preset-questions-ui.js"></script>
  <script src="../../js/chatbot/ui/chatbot-floating-options.js"></script> <!-- 新增引用 -->
  <script src="../../js/chatbot/ui/chatbot-ui.js"></script>
  <script src="../../js/chatbot/ui/chatbot-model-selector-ui.js"></script>

  <script src="../../js/chatbot/chatbot.js"></script>
  <script src="../../js/ui/dock/dock_logic.js"></script>
  <script src="../../js/processing/markdown_processor.js"></script>
  <script src="../../js/processing/sub_block_segmenter.js"></script>
  <script src="../../js/ui/dock/dock_settings_modal.js"></script> <!-- ADDED -->
  <script src="../../js/annotations/annotations_summary_modal.js"></script> <!-- ADDED -->
  <script src="../../js/history/history_detail_scripts.js"></script>

  <!-- ===================== -->
  <!-- 页面核心逻辑脚本 -->
  <!-- ===================== -->
  <script>
    // ---- 一键屏蔽非错误 console.log ----
    const PRODUCTION_MODE = false; // 设置为 true 来屏蔽 console.log, false 则不屏蔽
    if (PRODUCTION_MODE) {
      const originalConsoleLog = console.log;
      console.log = function() {
        // 可以选择在这里什么都不做，或者记录到一个备用日志系统
        // originalConsoleLog.apply(console, arguments); // 如果需要，可以取消注释来保留原始日志
      };
    }

    // ========== 新增：防止 showTab 重复渲染的锁 ==========
    let renderingTab = null;
    // =====================================================

    let isOriginalFirstInChunkCompare = true; // 状态变量：原文是否在左侧
    let docIdForLocalStorage = null; // To store the current document ID for localStorage keys
    window.docIdForLocalStorage = null; // 将变量挂载到 window 对象上，使其成为全局变量
    var currentVisibleTabId = null;  // To store the ID of the currently visible tab
    window.currentVisibleTabId = null; // 将变量挂载到 window 对象上，使其成为全局变量
    // let progressPercentageSpan = null; // MOVED to dock_logic.js
    // let progressPercentageVerboseSpan = null; // MOVED to dock_logic.js
    // let dockElement = null; // MOVED to dock_logic.js

    // NEW FUNCTION DEFINITION
    function adjustLongHeadingsToParagraphs(parentElement) {
      if (!parentElement) return;

      console.log('[adjustLongHeadingsToParagraphs] 开始处理，父元素:', parentElement);

      // 创建一个数组来存储所有需要处理的markdown-body元素
      let markdownBodies = [];

      // 检查父元素本身是否有markdown-body类
      if (parentElement.classList && parentElement.classList.contains('markdown-body')) {
        markdownBodies.push(parentElement);
        console.log('[adjustLongHeadingsToParagraphs] 父元素本身是markdown-body');
      }

      // 查找父元素内的所有markdown-body元素
      const childMarkdownBodies = parentElement.querySelectorAll('.markdown-body');
      childMarkdownBodies.forEach(el => {
        if (!markdownBodies.includes(el)) { // 避免重复
          markdownBodies.push(el);
        }
      });

      console.log('[adjustLongHeadingsToParagraphs] 找到 markdown-body 元素数量:', markdownBodies.length);

      markdownBodies.forEach((markdownBody, mbIdx) => {
        const headings = Array.from(markdownBody.querySelectorAll('h1, h2, h3, h4, h5, h6'));
        console.log(`[adjustLongHeadingsToParagraphs] markdown-body #${mbIdx} 中找到标题元素数量:`, headings.length);

        // 逆序遍历，防止DOM结构变化影响
        for (let hIdx = headings.length - 1; hIdx >= 0; hIdx--) {
          const heading = headings[hIdx];
          // Skip the main fileName heading if it's somehow caught by this logic
          if (heading.id === 'fileName') {
              console.log('[adjustLongHeadingsToParagraphs] 跳过 fileName 标题');
              continue;
          }

          // 补丁：如果没有 id，分配唯一 id
          if (!heading.id) heading.id = 'auto-hx-' + hIdx;

          const textContent = heading.textContent || "";
          console.log(`[adjustLongHeadingsToParagraphs] 标题 #${hIdx} (${heading.tagName}), ID: ${heading.id}, 文本长度: ${textContent.length}, 文本: "${textContent.substring(0, 50)}${textContent.length > 50 ? '...' : ''}"`);

          if (textContent.length > 30) {
            console.log(`[adjustLongHeadingsToParagraphs] 标题 #${hIdx} 文本长度 > 30，准备转换为段落`);

            try {
              const p = document.createElement('p');
              const originalTagName = heading.tagName.toLowerCase(); // 存储原始标签名

              // 递归移动所有子节点，彻底保留结构
              while (heading.firstChild) {
                p.appendChild(heading.firstChild);
              }

              // Copy all attributes from heading to p
              for (let i = 0; i < heading.attributes.length; i++) {
                const attr = heading.attributes[i];
                p.setAttribute(attr.name, attr.value);
              }

              // Add a class to indicate this was a converted heading,
              // in case specific styling is needed later.
              p.classList.add('converted-from-heading');
              p.dataset.originalTag = originalTagName; // 将原始标签名存储到 data-* 属性
              p.style.fontWeight = 'bold'; // 直接设置字体加粗

              heading.parentNode.replaceChild(p, heading);
              console.log(`[adjustLongHeadingsToParagraphs] 成功将标题 #${hIdx} 转换为段落（递归移动子节点）`);
            } catch (error) {
              console.error(`[adjustLongHeadingsToParagraphs] 转换标题 #${hIdx} 时出错:`, error);
            }
          }
        }
      });

      console.log('[adjustLongHeadingsToParagraphs] 处理完成');
    }

    function debounce(func, delay) {
      let timeout;
      return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), delay);
      };
    }

    function saveScrollPosition() {
      if (!docIdForLocalStorage || !currentVisibleTabId) return;
      const scrollableElement = document.documentElement; // Changed from .container
      if (scrollableElement) {
        const scrollKey = `scrollPos_${docIdForLocalStorage}_${currentVisibleTabId}`;
        localStorage.setItem(scrollKey, scrollableElement.scrollTop);
        // console.log(`Saved scroll for ${scrollKey} on documentElement: ${scrollableElement.scrollTop}`);
      }
    }
    // const debouncedSaveScrollPosition = debounce(saveScrollPosition, 300); // Debounce with 300ms
    const debouncedSaveScrollPosition = debounce(saveScrollPosition, 300); // 取消注释，修复问题

    function saveChatbotStateOnUnload() {
      if (docIdForLocalStorage && typeof window.isChatbotOpen !== 'undefined') {
        localStorage.setItem(`chatbotOpenState_${docIdForLocalStorage}`, window.isChatbotOpen);
        // console.log(`Saved chatbot state on beforeunload for ${docIdForLocalStorage}: ${window.isChatbotOpen}`);
      }
    }

    // MOVED to dock_logic.js: function updateReadingProgress() { ... }
    // MOVED to dock_logic.js: const debouncedUpdateReadingProgress = debounce(updateReadingProgress, 100);

    // MOVED to dock_logic.js: function updateHighlightSummary() { ... }
    // MOVED to dock_logic.js: function updateAnnotationSummary() { ... }
    // MOVED to dock_logic.js: function updateImageCount() { ... }
    // MOVED to dock_logic.js: function updateTableCount(contentElement) { ... }
    // MOVED to dock_logic.js: function updateFormulaCount(contentElement) { ... }
    // MOVED to dock_logic.js: function updateWordCount(contentElement) { ... }
    // MOVED to dock_logic.js: function updateAllDockStats() { ... }

    /**
     * 预处理 Markdown 文本，以安全地渲染图片、自定义语法（如上下标）并兼容 KaTeX。
     * - 将 Markdown 中的本地图片引用 (e.g., `![alt](images/img-1.jpeg.png)`) 替换为 Base64 嵌入式图片。
     * - 解析自定义的上下标语法 (e.g., `${base}^{sup}$`, `${base}_{sub}$`) 并转换为 HTML `<sup>` 和 `<sub>` 标签。
     * - 其他如 `$formula$` 和 `$$block formula$$` 的 LaTeX 标记会保留，交由后续的 `renderWithKatexFailback` 处理。
     *
     * @param {string} md -输入的 Markdown 文本。
     * @param {Array<Object>} images -一个包含图片对象的数组，每个对象应有 `name` 或 `id` (用于匹配) 和 `data` (Base64 图片数据或其前缀)。
     * @returns {string} 处理后的 Markdown 文本，其中图片被替换，自定义语法被转换。
     */
    // MOVED to js/markdown_processor.js: function safeMarkdown(md, images) { ... }

    /**
     * 使用 KaTeX 渲染 Markdown 文本中的数学公式，并提供降级处理。
     * 它会按以下顺序处理：
     * 1. 将长度较短 (<=10字符) 的块级公式 `$$...$$` 转换为行内公式 `$...\$`。
     * 2. 尝试使用 KaTeX 渲染行内公式 `$...\$`。如果渲染失败，则将公式内容包裹在 `<code>` 标签中显示。
     * 3. 尝试使用 KaTeX 渲染剩余的（通常是多行的）块级公式 `$$...$$`。如果渲染失败，则同样包裹在 `<code>` 标签中。
     * 4. 对处理完公式的文本，使用 `marked.parse()` 将其余 Markdown 内容转换为 HTML。
     *
     * @param {string} md - 经过 `safeMarkdown` 处理的 Markdown 文本。
     * @param {Function} customRenderer - 自定义的 Markdown 渲染器函数，用于处理特殊内容。
     * @returns {string} 包含渲染后公式和其余 Markdown 内容的 HTML 字符串。
     */
    // MOVED to js/markdown_processor.js: function renderWithKatexFailback(md, customRenderer) { ... }

    /**
     * 从当前页面的 URL 中获取指定查询参数的值。
     * @param {string} name - 要获取的查询参数的名称。
     * @returns {string|null} 查询参数的值，如果不存在则返回 null。
     */
    function getQueryParam(name) {
      const url = new URL(window.location.href);
      return url.searchParams.get(name);
    }
    /**
     * @type {Object|null}
     * @description 存储从 IndexedDB 加载的当前历史记录的详细数据。
     */
    let data = null;

    /**
     * 将块级元素内容按标点分割成子块 (span.sub-block)。
     * @param {HTMLElement} blockElement - 要分割的块级元素 (如 p, h1-h6)。
     * @param {string|number} parentBlockIndex - 父块的索引。
     */
    // MOVED to js/sub_block_segmenter.js: function segmentBlockIntoSubBlocks(blockElement, parentBlockIndex) { ... }

    /**
     * 异步渲染历史详情页面的主函数。
     * - 从 URL 查询参数中获取记录 ID。
     * - 使用 `getResultFromDB` (来自 storage.js) 从 IndexedDB 加载对应的历史数据。
     * - 如果数据成功加载：
     *   - 更新页面标题 (`#fileName`) 和元数据 (`#fileMeta`)。
     *   - 根据数据中是否存在有效的分块信息 (`ocrChunks`, `translatedChunks`)，
     *     决定默认显示的标签页（优先显示分块对比，否则显示 OCR 内容）。
     * - 如果未找到数据，则显示提示信息。
     * @async
     */
    async function renderDetail() {
      const id = getQueryParam('id');
      if (!id) return;
      docIdForLocalStorage = id; // Store doc ID for localStorage operations
      window.docIdForLocalStorage = id; // 同时更新挂载到 window 对象上的变量

      // Restore chatbot open state
      const savedChatbotOpenState = localStorage.getItem(`chatbotOpenState_${docIdForLocalStorage}`);
      if (savedChatbotOpenState === 'true') {
        window.isChatbotOpen = true;
      } else if (savedChatbotOpenState === 'false') {
        window.isChatbotOpen = false;
      }

      // 从localStorage恢复保存的比例设置
      const savedChunkCompareRatio = localStorage.getItem(`chunkCompareRatio_${docIdForLocalStorage}`);
      if (savedChunkCompareRatio !== null && !isNaN(parseFloat(savedChunkCompareRatio))) {
        window.chunkCompareRatio = parseFloat(savedChunkCompareRatio);
      }

      // console.log(`Chatbot state after attempting restore from localStorage for ${docIdForLocalStorage}: ${window.isChatbotOpen}`);

      // Initialize Dock Logic once docIdForLocalStorage is available
      if (typeof window.DockLogic !== 'undefined' && typeof window.DockLogic.init === 'function') {
        window.DockLogic.init(docIdForLocalStorage);
      } else {
        console.error("DockLogic not available or init function missing.");
      }

      data = await getResultFromDB(id);
      window.data = data; // for debugging
      if (!data) {
        document.getElementById('fileName').textContent = '未找到数据';
        document.getElementById('fileMeta').textContent = '';
        document.getElementById('tabContent').innerHTML = '';
        return;
      }

      // === 新增：如果没有翻译内容，隐藏"仅翻译"和"分块对比"按钮 ===
      if (!data.translation || data.translation.trim() === "") {
        document.getElementById('tab-translation').style.display = 'none';
        document.getElementById('tab-chunk-compare').style.display = 'none';
      }
      document.getElementById('fileName').textContent = data.name;
      document.getElementById('fileMeta').innerHTML = `时间: ${new Date(data.time).toLocaleString()} &nbsp; | &nbsp; 图片数: ${data.images ? data.images.length : 0}`;

      // ========== 确保批注数据在渲染前加载 ==========
      if (id) { // 确保我们有文档 ID
        try {
          const annotations = await getAnnotationsForDocFromDB(id);
          console.log(`Annotations for docId '${id}' (loaded in renderDetail):`, annotations);
          data.annotations = annotations || []; // 存储到 data 对象，确保是数组
          // updateAnnotationSummary(); // Handled by updateAllDockStats via showTab
          // updateHighlightSummary(); // Handled by updateAllDockStats via showTab
        } catch (error) {
          console.error(`Error loading annotations for docId '${id}' in renderDetail:`, error);
          data.annotations = []; // 出错时也确保是个空数组
          // updateAnnotationSummary(); // Handled by updateAllDockStats via showTab
          // updateHighlightSummary(); // Handled by updateAllDockStats via showTab
        }
      } else {
        // updateAnnotationSummary(); // Handled by updateAllDockStats via showTab
        // updateHighlightSummary(); // Handled by updateAllDockStats via showTab
      }
      // =============================================

      // ========== 在 window.data 设置并填充批注后，显式加载聊天记录 ==========
      if (window.data) {
        if (window.ChatbotCore && typeof window.ChatbotCore.reloadChatHistoryAndUpdateUI === 'function' &&
            window.ChatbotUI && typeof window.ChatbotUI.updateChatbotUI === 'function') {
          console.log('renderDetail: Calling reloadChatHistoryAndUpdateUI after window.data and annotations are set. Current docId:', window.ChatbotCore.getCurrentDocId ? window.ChatbotCore.getCurrentDocId() : 'unknown');
          window.ChatbotCore.reloadChatHistoryAndUpdateUI(window.ChatbotUI.updateChatbotUI);
        } else {
          console.error('renderDetail: ChatbotCore or ChatbotUI not fully available for history reload.');
        }
      }
      // =================================================================

      // Initialize annotation system after data is loaded and DOM is likely ready
      if (typeof window.initializeGlobalAnnotationVariables === 'function') {
        window.initializeGlobalAnnotationVariables();
      }
      if (typeof window.initAnnotationSystem === 'function') {
        window.initAnnotationSystem();
      } else {
        console.error("initAnnotationSystem is not defined. Check js/annotation_logic.js");
      }

      // Determine initial tab, AFTER annotations are loaded
      let initialTab = 'ocr'; // Default tab
      if (docIdForLocalStorage) {
        const savedTabKey = `activeTab_${docIdForLocalStorage}`;
        const savedTab = localStorage.getItem(savedTabKey);
        if (
          savedTab &&
          ['ocr', 'translation', 'chunk-compare'].includes(savedTab) &&
          !(savedTab !== 'ocr' && (!data.translation || data.translation.trim() === ""))
        ) {
          initialTab = savedTab;
        } else if (
          data.ocrChunks && data.ocrChunks.length > 0 &&
          data.translatedChunks && data.translatedChunks.length > 0 &&
          data.ocrChunks.length === data.translatedChunks.length &&
          data.translation && data.translation.trim() !== ""
        ) {
          initialTab = 'chunk-compare';
        }
      } else if (
        data.ocrChunks && data.ocrChunks.length > 0 &&
        data.translatedChunks && data.translatedChunks.length > 0 &&
        data.ocrChunks.length === data.translatedChunks.length &&
        data.translation && data.translation.trim() !== ""
      ) {
        initialTab = 'chunk-compare';
      }

      // 现在，在批注肯定加载完毕后，才调用 showTab
      showTab(initialTab);

      // The block for loading annotations (previously around line 415) has been moved up.

      // Add scroll listener for saving scroll position
      window.removeEventListener('scroll', debouncedSaveScrollPosition);
      window.addEventListener('scroll', debouncedSaveScrollPosition);
      // Add scroll listener for updating reading progress - MOVED TO DOCK_LOGIC.JS
      // window.removeEventListener('scroll', debouncedUpdateReadingProgress);
      // window.addEventListener('scroll', debouncedUpdateReadingProgress);

      // Add listener to save chatbot state on page unload
      window.removeEventListener('beforeunload', saveChatbotStateOnUnload);
      window.addEventListener('beforeunload', saveChatbotStateOnUnload);

      // Manage Annotations Link Click - Changed to Settings Link - MOVED TO DOCK_LOGIC.JS
      // const settingsLink = document.getElementById('settings-link');
      // if (settingsLink) {
      //   settingsLink.onclick = function(event) {
      //     event.preventDefault();
      //     alert('管理页面即将推出！'); // Updated alert message
      //   };
      // }

      // Dock Toggle Button Click - MOVED TO DOCK_LOGIC.JS
      // const dockToggleBtn = document.getElementById('dock-toggle-btn');
      // const dock = document.getElementById('bottom-left-dock');
      // if (dockToggleBtn && dock) {
      //   // Restore collapsed state
      //   const dockCollapsedKey = `dockCollapsed_${docIdForLocalStorage}`;
      //   const isCollapsed = localStorage.getItem(dockCollapsedKey) === 'true';
      //   if (isCollapsed) {
      //     dock.classList.add('dock-collapsed');
      //     dockToggleBtn.innerHTML = '<i class="fa fa-chevron-up"></i>';
      //     dockToggleBtn.title = '展开';
      //   }

      //   dockToggleBtn.onclick = function(event) {
      //     event.preventDefault();
      //     const currentlyCollapsed = dock.classList.toggle('dock-collapsed');
      //     if (currentlyCollapsed) {
      //       this.innerHTML = '<i class="fa fa-chevron-up"></i>';
      //       this.title = '展开';
      //       localStorage.setItem(dockCollapsedKey, 'true');
      //     } else {
      //       this.innerHTML = '<i class="fa fa-chevron-down"></i>';
      //       this.title = '折叠';
      //       localStorage.setItem(dockCollapsedKey, 'false');
      //     }
      //   };
      // }
    }

    /**
     * 切换并显示指定的标签页内容。
     * - 更新标签按钮的激活状态 (`active` class)。
     * - 根据传入的 `tab` 参数 ( 'ocr', 'translation', 'chunk-compare' )，生成对应的 HTML 内容。
     * - OCR 和翻译标签页：直接渲染 `data.ocr` 或 `data.translation` 字段。
     * - 分块对比标签页 (`chunk-compare`)：
     *   - 检查 `data.ocrChunks` 和 `data.translatedChunks` 是否有效且数量匹配。
     *   - 如果有效，则为每一对原文/译文块生成对比视图。使用 `renderLevelAlignedFlex` 进行布局。
     *   - 提供一个按钮 (`#swap-chunks-btn`) 用于切换原文和译文在对比视图中的左右位置。
     *   - 如果分块数据无效，则显示提示信息。
     * - 将生成的 HTML 设置到 `#tabContent` 区域。
     * - 调用 `window.refreshTocList()` 更新目录（TOC）。
     *
     * @param {string} tab - 要显示的标签页标识符 ('ocr', 'translation', or 'chunk-compare')。
     */
    function showTab(tab) {
      // === 新增：没有翻译内容时禁止切换到翻译和对比页 ===
      if ((tab === 'translation' || tab === 'chunk-compare') && (!data || !data.translation || data.translation.trim() === "")) {
        alert('没有翻译内容，无法显示该页面');
        return;
      }
      // ========== 保证内容标识符始终正确 ==========
      if (tab === 'ocr') {
        window.globalCurrentContentIdentifier = 'ocr';
      } else if (tab === 'translation') {
        window.globalCurrentContentIdentifier = 'translation';
      } else {
        window.globalCurrentContentIdentifier = '';
      }
      // ========== 防抖锁：防止同一 tab 重复渲染 ==========
      if (renderingTab === tab) {
        console.log(`[showTab] Tab ${tab} 正在渲染中，跳过重复渲染`);
        return;
      }
      renderingTab = tab;
      // ================================================
      // 性能测试断点 - 总渲染
      console.time('[性能] showTab_总渲染');
      currentVisibleTabId = tab; // Update global current tab ID
      window.currentVisibleTabId = tab; // 同时更新挂载到 window 对象上的变量
      window.currentBlockTokensForCopy = window.currentBlockTokensForCopy || {}; // Initialize if not exists

      // ========== 新增：用局部变量保存内容标识符 ==========
      let contentIdentifier = '';
      if (tab === 'ocr') {
        contentIdentifier = 'ocr';
      } else if (tab === 'translation') {
        contentIdentifier = 'translation';
      }
      window.globalCurrentContentIdentifier = contentIdentifier;
      console.log('[showTab] 设置 window.globalCurrentContentIdentifier =', contentIdentifier);
      // ==================================================

      if (docIdForLocalStorage) {
        const activeTabKey = `activeTab_${docIdForLocalStorage}`;
        localStorage.setItem(activeTabKey, tab);
        // console.log(`Saved active tab for ${docIdForLocalStorage}: ${tab}`);
      }

      document.getElementById('tab-ocr').classList.remove('active');
      document.getElementById('tab-translation').classList.remove('active');
      // document.getElementById('tab-compare').classList.remove('active'); // 对应按钮已注释，此行也可注释
      document.getElementById('tab-chunk-compare').classList.remove('active');

      let html = '';
      let contentContainerId = ''; // 用于 applyAnnotationsToContent
      let activeContentElement = null; // 用于 applyAnnotationsToContent
      const significantTokenTypes = ['paragraph', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'hr'];

      // ---- 增加日志 ----
      // 日志现在可以准确反映 globalCurrentContentIdentifier
      console.log(`[showTab - ${tab}] 即将渲染。当前 window.globalCurrentContentIdentifier:`, window.globalCurrentContentIdentifier);
      if (data && data.annotations) {
          console.log(`[showTab - ${tab}] data.annotations (长度 ${data.annotations.length}):`, JSON.parse(JSON.stringify(data.annotations)));
      } else {
          console.log(`[showTab - ${tab}] data.annotations 不可用或为空。`);
      }
      // ---- 日志结束 ----

      if(tab === 'ocr') {
        document.getElementById('tab-ocr').classList.add('active');
        contentContainerId = 'ocr-content-wrapper';
        let ocrText = data.ocr || '';
        // 性能测试断点 - OCR渲染
        console.time('[性能] OCR分批渲染');
        html = `<h3>OCR内容</h3><div id="${contentContainerId}" class="markdown-body content-wrapper"></div>`;
      } else if(tab === 'translation') {
        document.getElementById('tab-translation').classList.add('active');
        contentContainerId = 'translation-content-wrapper';
        html = `<h3>翻译内容</h3><div id="${contentContainerId}" class="markdown-body content-wrapper"></div>`;
        console.time('[性能] 翻译分批渲染');
      } else if (tab === 'chunk-compare') {
        // window.globalCurrentContentIdentifier = ''; // 已在函数开头正确设置
        document.getElementById('tab-chunk-compare').classList.add('active');
        if (data.ocrChunks && data.ocrChunks.length > 0 && data.translatedChunks && data.translatedChunks.length === data.ocrChunks.length) {
            html = `
              <div class="chunk-compare-title-bar">
                <h3>分块对比</h3>
                <button id="swap-chunks-btn" title="切换原文/译文位置">⇆</button>
              </div>
              <div class="chunk-compare-container">
            `;
            /**
             * 解析Markdown文本为逻辑块数组，主要基于标题进行分割。
             * 代码块 (```...```) 会被视为单个块的一部分，不会被分割。
             * @param {string} md - Markdown文本。
             * @returns {Array<Object>} 每个对象包含 `{ content: string }`。
             */
            function parseMarkdownBlocks(md) {
              const lines = (md || '').split(/\r?\n/);
              const blocks = [];
              let buffer = [];
              let inCode = false;
              let isFirstBlock = true;
              function flush() {
                if (buffer.length) {
                  blocks.push({ content: buffer.join('\n') });
                  buffer = [];
                }
              }
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (/^\s*```/.test(line)) { // 代码块
                  inCode = !inCode;
                  buffer.push(line);
                  continue;
                }
                if (inCode) {
                  buffer.push(line);
                  continue;
                }
                if (/^\s*#/.test(line)) { // 标题作为新分块的起点
                  if (!isFirstBlock) flush();
                  isFirstBlock = false;
                  buffer.push(line);
                  continue;
                }
                // 普通内容、列表、空行等都合并到当前块
                buffer.push(line);
              }
              flush();
              return blocks;
            }
            /**
             * 对齐两组Markdown逻辑块，用于并排显示。
             * 简单地按索引逐个配对，如果某一组块少，则对应位置为空字符串。
             * @param {Array<Object>} blocks1 - 第一组块。
             * @param {Array<Object>} blocks2 - 第二组块。
             * @returns {Array<Array<string>>} 每个内部数组包含两个字符串 `[block1_content, block2_content]`。
             */
            function alignBlocks(blocks1, blocks2) {
              // 简单按类型和顺序对齐
              const maxLen = Math.max(blocks1.length, blocks2.length);
              const aligned = [];
              for (let i = 0; i < maxLen; i++) {
                aligned.push([
                  blocks1[i] ? blocks1[i].content : '',
                  blocks2[i] ? blocks2[i].content : ''
                ]);
              }
              return aligned;
            }
            /**
             * 渲染单个OCR块和其对应的翻译块的对齐视图，支持分层结构。
             * - 它首先使用 `parseMarkdownBlocks` 将OCR和翻译文本分割成小块（基于标题）。
             * - 然后使用 `alignBlocks` 对齐这些小块。
             * - 为每个对齐的小块对生成并排的HTML结构，用于显示原文和译文。
             * - 提供工具栏按钮，用于切换显示模式（对比、仅原文、仅译文）、复制整块内容以及导航到上下块。
             * - 原始块内容存储在 `window.blockRawContent_[blockIndex]` 中，供复制功能使用。
             *
             * @param {string} ocrChunk - OCR文本块。
             * @param {string} translatedChunk - 对应的翻译文本块。
             * @param {Array<Object>} images - 与此文档关联的图片数据。
             * @param {number} blockIndex - 当前大块在整个文档分块中的索引。
             * @param {number} totalBlocks - 文档分块的总数。
             * @returns {string} 生成的HTML字符串，用于显示对齐的块内容。
             */
            function renderLevelAlignedFlex(ocrChunk, translatedChunk, images, blockIndex, totalBlocks) {
              const ocrBlocks = parseMarkdownBlocks(ocrChunk);
              const transBlocks = parseMarkdownBlocks(translatedChunk);
              const aligned = alignBlocks(ocrBlocks, transBlocks);
              let showMode = window[`showMode_block_${blockIndex}`] || 'both';

              // 在分块对比内部也尝试使用自定义渲染器
              // 注意：这里的 annotations 应该是整个文档的，contentIdentifier 需要根据当前块是原文还是译文来确定
              // 为了简化，我们暂时假设分块对比中的内容不直接参与这种精细的预标注，
              // 或者需要更复杂的逻辑来传递正确的 contentIdentifier
              // MODIFIED: Pass empty array for annotations in chunk-compare mode to disable highlights/annotations
              const annotationsForChunkRender = [];
              const ocrRenderer = createCustomMarkdownRenderer(annotationsForChunkRender, 'ocr', MarkdownProcessor.renderWithKatexFailback);
              const transRenderer = createCustomMarkdownRenderer(annotationsForChunkRender, 'translation', MarkdownProcessor.renderWithKatexFailback);

              // 整块复制按钮
              let html = `
                <div class="block-toolbar" data-block-toolbar="${blockIndex}">
                  <div class="block-toolbar-left">
                    <span class="block-mode-btn ${showMode === 'both' ? 'active' : ''}" data-mode="both" data-block="${blockIndex}">对比</span>
                    <span class="block-mode-btn ${showMode === 'ocr' ? 'active' : ''}" data-mode="ocr" data-block="${blockIndex}">原文</span>
                    <span class="block-mode-btn ${showMode === 'trans' ? 'active' : ''}" data-mode="trans" data-block="${blockIndex}">译文</span>
                    <button class="block-copy-btn" data-block="${blockIndex}" title="复制本块内容">复制本块</button>
                  </div>
                  <div class="block-toolbar-right">
                    ${blockIndex > 0 ? `<button class="block-nav-btn" data-dir="prev" data-block="${blockIndex}" title="上一段">↑</button>` : ''}
                    ${blockIndex < totalBlocks-1 ? `<button class="block-nav-btn" data-dir="next" data-block="${blockIndex}" title="下一段">↓</button>` : ''}
                  </div>
                </div>
              `;
              for (let i = 0; i < aligned.length; i++) {
                html += `
                  <div class="align-flex block-flex block-flex-${blockIndex} ${showMode==='ocr'?'block-mode-ocr-only':showMode==='trans'?'block-mode-trans-only':'block-mode-both'}" data-block="${blockIndex}" data-align-index="${i}">
                    <div class="align-block align-block-ocr">
                      <div class="align-title">
                        <span>原文</span>
                        <button class="block-struct-copy-btn" data-block="${blockIndex}" data-type="ocr" data-idx="${i}" title="复制原文结构">复制</button>
                      </div>
                      <div class="align-content markdown-body">${MarkdownProcessor.renderWithKatexFailback(MarkdownProcessor.safeMarkdown(aligned[i][0], images), isOriginalFirstInChunkCompare ? ocrRenderer : transRenderer)}</div>
                    </div>
                    <div class="splitter" title="拖动调整比例"></div>
                    <div class="align-block align-block-trans">
                      <div class="align-title">
                        <span>译文</span>
                        <button class="block-struct-copy-btn" data-block="${blockIndex}" data-type="trans" data-idx="${i}" title="复制译文结构">复制</button>
                      </div>
                      <div class="align-content markdown-body">${MarkdownProcessor.renderWithKatexFailback(MarkdownProcessor.safeMarkdown(aligned[i][1], images), isOriginalFirstInChunkCompare ? transRenderer : ocrRenderer)}</div>
                    </div>
                  </div>
                `;
              }
              // 记录原始内容，供复制用
              window[`blockRawContent_${blockIndex}`] = aligned;
              return html;
            }
            // 渲染每个分块，增加唯一id
            for (let i = 0; i < data.ocrChunks.length; i++) {
                const ocrChunk = data.ocrChunks[i] || '';
                const translatedChunk = data.translatedChunks[i] || '';
                let blockHtmlToRender;
                let outerBlockTitle;

                if (isOriginalFirstInChunkCompare) {
                    // 当原文在左侧时，调用 renderLevelAlignedFlex(原文, 译文)
                    // window[`blockRawContent_${i}`] 将存储 [原文子块, 译文子块]
                    blockHtmlToRender = renderLevelAlignedFlex(ocrChunk, translatedChunk, data.images, i, data.ocrChunks.length);
                    outerBlockTitle = `原文块 ${i+1}`;
                } else {
                    // 当译文在左侧时，调用 renderLevelAlignedFlex(译文, 原文)
                    // window[`blockRawContent_${i}`] 将存储 [译文子块, 原文子块]
                    blockHtmlToRender = renderLevelAlignedFlex(translatedChunk, ocrChunk, data.images, i, data.ocrChunks.length);
                    outerBlockTitle = `译文块 ${i+1}`; // 标题也反映左侧内容
                }
                html += `<div class="chunk-pair">`;
                html += `<div id="block-${i}" class="block-outer">`; // id 用于导航
                html += `<h4>${outerBlockTitle}</h4>`;
                html += blockHtmlToRender;
                html += `</div></div>`;
            }
            html += '</div>';
            // 绑定每个分块的切换按钮和导航按钮事件
            setTimeout(() => {
              // 拖动分割条实现 - 使用CSS变量而不是直接设置样式
              let ratio = window.chunkCompareRatio;
              if (typeof ratio !== 'number' || isNaN(ratio)) ratio = 0.5;
              window.chunkCompareRatio = ratio; // 确保全局变量被设置

              function applyRatioToAll() {
                const currentRatio = window.chunkCompareRatio || 0.5;
                document.querySelectorAll('.align-flex').forEach(flex => {
                  // 使用CSS变量而不是直接设置样式
                  flex.style.setProperty('--ocr-ratio', (currentRatio * 100) + '%');
                  flex.style.setProperty('--trans-ratio', ((1 - currentRatio) * 100) + '%');
                });
              }
              applyRatioToAll();

              // 重新绑定分块对比工具栏按钮事件 - 使用CSS类管理显示模式
              document.querySelectorAll('.block-mode-btn').forEach(btn => {
                btn.onclick = function() {
                  const blockIndex = this.dataset.block;
                  const mode = this.dataset.mode;
                  window[`showMode_block_${blockIndex}`] = mode;

                  // 更新按钮激活状态
                  document.querySelectorAll(`.block-mode-btn[data-block="${blockIndex}"]`).forEach(b => {
                    b.classList.remove('active');
                  });
                  this.classList.add('active');

                  // 使用CSS类管理显示模式，而不是直接操作样式
                  document.querySelectorAll(`.block-flex-${blockIndex}`).forEach(flexPair => {
                    // 移除所有模式类
                    flexPair.classList.remove('block-mode-ocr-only', 'block-mode-trans-only', 'block-mode-both');

                    // 添加对应的模式类
                    if (mode === 'ocr') {
                      flexPair.classList.add('block-mode-ocr-only');
                    } else if (mode === 'trans') {
                      flexPair.classList.add('block-mode-trans-only');
                    } else { // mode === 'both'
                      flexPair.classList.add('block-mode-both');
                      // 当切换回 both 模式时，重新应用拖动条的比例
                      applyRatioToAllFlexPairsInBlock(blockIndex);
                    }
                  });
                };
              });

              // 辅助函数：将当前拖动比例应用到指定blockIndex的所有flexPair
              function applyRatioToAllFlexPairsInBlock(blockIndexToUpdate) {
                const currentRatio = window.chunkCompareRatio || 0.5;
                document.querySelectorAll(`.block-flex-${blockIndexToUpdate}`).forEach(flex => {
                  // 使用CSS变量
                  flex.style.setProperty('--ocr-ratio', (currentRatio * 100) + '%');
                  flex.style.setProperty('--trans-ratio', ((1 - currentRatio) * 100) + '%');
                });
              }

              // 初始化拖动比例应用到所有分块的所有对比对
              // 确保在按钮事件绑定之后，但在第一次渲染时就能正确设置
              if (document.querySelector('.align-flex')) { // 确保有可操作的元素
                const allBlockIndexes = new Set();
                document.querySelectorAll('[data-block]').forEach(el => allBlockIndexes.add(el.dataset.block));
                allBlockIndexes.forEach(idx => {
                    if(window[`showMode_block_${idx}`] === undefined || window[`showMode_block_${idx}`] === 'both') {
                        applyRatioToAllFlexPairsInBlock(idx);
                    }
                });
              }

              // 拖动分割条实现
              let draggingSplitterInfo = null; // {splitter, flexContainer, startX, initialOcrBasisPx}

              document.querySelectorAll('.splitter').forEach(splitter => {
                splitter.onmousedown = function(e) {
                  const flexContainer = e.target.closest('.align-flex');
                  if (!flexContainer) return;
                  const ocrBlock = flexContainer.querySelector('.align-block-ocr');
                  if (!ocrBlock || getComputedStyle(ocrBlock).display === 'none') return; // 只在对比模式下拖动

                  draggingSplitterInfo = {
                    splitter: e.target,
                    flexContainer: flexContainer,
                    startX: e.clientX,
                    initialOcrBasisPx: ocrBlock.offsetWidth
                  };

                  e.target.classList.add('active');
                  // 使用CSS类而不是直接设置样式
                  document.body.classList.add('dragging-cursor');
                  e.preventDefault();
                };
              });

              document.addEventListener('mousemove', function(e) {
                if (!draggingSplitterInfo) return;

                const { splitter, flexContainer, startX, initialOcrBasisPx } = draggingSplitterInfo;
                const ocrBlock = flexContainer.querySelector('.align-block-ocr');
                const transBlock = flexContainer.querySelector('.align-block-trans');
                if (!ocrBlock || !transBlock) return;

                const dx = e.clientX - startX;
                const containerWidth = flexContainer.offsetWidth;
                if (containerWidth === 0) return;

                let newOcrWidthPx = initialOcrBasisPx + dx;
                // 限制最小/最大宽度，例如总宽度的20%到80%
                const minWidthPx = containerWidth * 0.2;
                const maxWidthPx = containerWidth * 0.8;
                newOcrWidthPx = Math.max(minWidthPx, Math.min(newOcrWidthPx, maxWidthPx));

                const newOcrRatio = newOcrWidthPx / containerWidth;

                // 更新当前拖动的块的比例
                flexContainer.style.setProperty('--ocr-ratio', (newOcrRatio * 100) + '%');
                flexContainer.style.setProperty('--trans-ratio', ((1 - newOcrRatio) * 100) + '%');

                // 更新全局比例，以便新加载的块或切换回对比模式时使用
                window.chunkCompareRatio = newOcrRatio;

                // 调用applyRatioToAll()使所有其他块的比例联动
                // 但排除当前正在拖动的块，避免视觉抖动
                document.querySelectorAll('.align-flex').forEach(flex => {
                  if (flex !== flexContainer) {
                    flex.style.setProperty('--ocr-ratio', (newOcrRatio * 100) + '%');
                    flex.style.setProperty('--trans-ratio', ((1 - newOcrRatio) * 100) + '%');
                  }
                });
              });

              document.addEventListener('mouseup', function() {
                if (draggingSplitterInfo) {
                  draggingSplitterInfo.splitter.classList.remove('active');
                  draggingSplitterInfo = null;
                  // 使用CSS类而不是直接设置样式
                  document.body.classList.remove('dragging-cursor');

                  // 持久化当前的比例设置到localStorage
                  if (docIdForLocalStorage && typeof window.chunkCompareRatio === 'number') {
                    localStorage.setItem(`chunkCompareRatio_${docIdForLocalStorage}`, window.chunkCompareRatio.toString());
                  }
                }
              });

              document.querySelectorAll('.block-copy-btn').forEach(btn => {
                btn.onclick = function() {
                  const blockIndex = this.dataset.block;
                  const rawBlockContent = window[`blockRawContent_${blockIndex}`];
                  const currentMode = window[`showMode_block_${blockIndex}`] || 'both'; // 获取当前模式

                  if (rawBlockContent && Array.isArray(rawBlockContent)) {
                    let textToCopy = "";
                    let alertMessage = "";

                    if (currentMode === 'ocr') {
                      rawBlockContent.forEach(pair => {
                        // 如果原文在左，pair[0]是原文；如果译文在左，pair[0]是译文
                        const ocrText = isOriginalFirstInChunkCompare ? (pair && pair[0]) : (pair && pair[1]);
                        if (ocrText) textToCopy += ocrText + "\n\n";
                      });
                      textToCopy = textToCopy.trim();
                      alertMessage = `第 ${parseInt(blockIndex) + 1} 块的 原文 已复制!`;
                    } else if (currentMode === 'trans') {
                      rawBlockContent.forEach(pair => {
                        // 如果原文在左，pair[1]是译文；如果译文在左，pair[1]是原文
                        const transText = isOriginalFirstInChunkCompare ? (pair && pair[1]) : (pair && pair[0]);
                        if (transText) textToCopy += transText + "\n\n";
                      });
                      textToCopy = textToCopy.trim();
                      alertMessage = `第 ${parseInt(blockIndex) + 1} 块的 译文 已复制!`;
                    } else { // mode === 'both'
                      rawBlockContent.forEach(pair => {
                        const ocrText = isOriginalFirstInChunkCompare ? (pair && pair[0]) : (pair && pair[1]);
                        const transText = isOriginalFirstInChunkCompare ? (pair && pair[1]) : (pair && pair[0]);
                        if (ocrText) textToCopy += "原文:\n" + ocrText + "\n\n";
                        if (transText) textToCopy += "译文:\n" + transText + "\n\n";
                      });
                      textToCopy = textToCopy.trim();
                      alertMessage = `第 ${parseInt(blockIndex) + 1} 块的 原文和译文 已复制!`;
                    }

                    if (textToCopy) {
                      navigator.clipboard.writeText(textToCopy)
                        .then(() => alert(alertMessage))
                        .catch(err => {
                          console.error('复制失败:', err);
                          alert('复制失败，请查看控制台。');
                        });
                    } else {
                      alert('没有内容可复制。');
                    }
                  }
                };
              });

              document.querySelectorAll('.block-struct-copy-btn').forEach(btn => {
                btn.onclick = function() {
                  const blockIndex = this.dataset.block;
                  const type = this.dataset.type; // 'ocr' or 'trans'
                  const structIdx = parseInt(this.dataset.idx);
                  const rawBlockContent = window[`blockRawContent_${blockIndex}`];
                  if (rawBlockContent && rawBlockContent[structIdx]) {
                    const textToCopy = (type === 'ocr') ? rawBlockContent[structIdx][0] : rawBlockContent[structIdx][1];
                    navigator.clipboard.writeText(textToCopy)
                      .then(() => alert(`第 ${parseInt(blockIndex) + 1} 块的 ${type === 'ocr' ? '原文' : '译文'} (结构 ${structIdx + 1}) 已复制!`))
                      .catch(err => console.error('复制失败:', err));
                  }
                };
              });

              document.querySelectorAll('.block-nav-btn').forEach(btn => {
                btn.onclick = function() {
                  const blockIndex = parseInt(this.dataset.block);
                  const direction = this.dataset.dir;
                  let targetIndex = direction === 'prev' ? blockIndex - 1 : blockIndex + 1;
                  const targetElement = document.getElementById(`block-${targetIndex}`);
                  if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // 可选：添加高亮效果
                    targetElement.classList.add('block-highlight');
                    setTimeout(() => targetElement.classList.remove('block-highlight'), 1500);
                  }
                };
              });

            }, 0);
        } else {
            html = '<h3>分块对比</h3><p>此记录没有有效的分块对比数据。</p>';
            if (!data.ocrChunks || !data.translatedChunks) {
                 html += '<p>原因：缺少分块数据 (ocrChunks or translatedChunks missing)。</p>';
            } else if (data.ocrChunks.length !== data.translatedChunks.length) {
                 html += `<p>原因：原文块数量 (${data.ocrChunks.length}) 与译文块数量 (${data.translatedChunks.length}) 不匹配。</p>`;
            } else {
                 html += '<p>原因：分块数据为空。</p>';
            }
        }
      }
      document.getElementById('tabContent').innerHTML = html;
      // 分批渲染逻辑（仅对 OCR 和翻译标签页生效）
      if(tab === 'ocr' || tab === 'translation') {
        const contentText = tab === 'ocr' ? (data.ocr || '') : (data.translation || '');
        const contentContainer = document.getElementById(contentContainerId);
        const batchSize = 30; // 每批渲染的段落数，可调整
        const tokens = marked.lexer(contentText).filter(token => ['paragraph','heading','code','table','blockquote','list','html','hr'].includes(token.type));
        window.currentBlockTokensForCopy[tab] = tokens;
        const customRenderer = createCustomMarkdownRenderer(data.annotations, tab, MarkdownProcessor.renderWithKatexFailback);

        // Define segmentInBatches here, so it's in scope for renderBatch's callback
        function segmentInBatches(containerElement, batchSize = 10, delay = 50, onDone) {
            const blocks = Array.from(containerElement.children).filter(node => node.nodeType === Node.ELEMENT_NODE);
            let i = 0;
            function runBatch() {
                const end = Math.min(i + batchSize, blocks.length);
                for (; i < end; i++) {
                    const el = blocks[i];
                    el.dataset.blockIndex = String(i);
                    if (window.SubBlockSegmenter && typeof window.SubBlockSegmenter.segment === 'function') {
                        window.SubBlockSegmenter.segment(el, i);
                    } else {
                        console.error("SubBlockSegmenter.segment is not available.");
                    }
                }
                if (i < blocks.length) {
                    setTimeout(runBatch, delay);
                } else {
                    // 所有父块的子块分割完成
                    onDone && onDone();
                }
            }
            runBatch();
        }

        function renderBatch(startIdx, onDoneAllBatchesCallback) { // Added onDoneAllBatchesCallback parameter
          const fragment = document.createDocumentFragment();
          for(let i=startIdx;i<Math.min(tokens.length, startIdx+batchSize);i++){
            const htmlStr = MarkdownProcessor.renderWithKatexFailback(MarkdownProcessor.safeMarkdown(tokens[i].raw || '', data.images), customRenderer);
            const wrap = document.createElement('div');
            wrap.innerHTML = htmlStr;
            while(wrap.firstChild) fragment.appendChild(wrap.firstChild);
          }
          contentContainer.appendChild(fragment);
          if(startIdx+batchSize<tokens.length) {
            setTimeout(()=>renderBatch(startIdx+batchSize, onDoneAllBatchesCallback),0); // Pass callback along
          } else {
            // 所有批次渲染完成
            if(tab==='ocr') console.timeEnd('[性能] OCR分批渲染');
            if(tab==='translation') console.timeEnd('[性能] 翻译分批渲染');

            // Use requestAnimationFrame to allow browser to paint/layout before further DOM manipulation
            requestAnimationFrame(() => {
              console.log(`[showTab - ${tab}] RAF triggered after all batches rendered.`);
              const currentTabContentWrapper = document.getElementById(contentContainerId);
              if (currentTabContentWrapper) {
                  adjustLongHeadingsToParagraphs(currentTabContentWrapper);
              }

              // Now, call segmentInBatches on the fully rendered content
              activeContentElement = document.getElementById(contentContainerId); // Re-affirm activeContentElement
              if (activeContentElement) {
                segmentInBatches(activeContentElement, 10, 50, () => {
                    // This is the onDone callback for segmentInBatches
                    // All segmentation is complete, now apply annotations and listeners
                    if (data && data.annotations && typeof window.applyBlockAnnotations === 'function') {
                        window.applyBlockAnnotations(activeContentElement, data.annotations, contentIdentifier);
                    }
                    // Finally, update Dock stats and TOC as content and structure are finalized
                    if (window.DockLogic && typeof window.DockLogic.updateStats === 'function') {
                      console.log(`[showTab - ${tab}] OCR/Translation: segmentInBatches done, forcing Dock stats update.`);
                      window.DockLogic.updateStats(window.data, currentVisibleTabId);
                    }
                    if (typeof window.refreshTocList === 'function') {
                      console.log(`[showTab - ${tab}] OCR/Translation: segmentInBatches done, forcing TOC refresh.`);
                      window.refreshTocList();
                    }
                    // ========== 渲染完成，解锁 ==========='
                    renderingTab = null;
                    // ====================================
                    // ========== 内容加载完成 =============
                    window.contentReady = true;
                    console.log('[DEBUG] window.contentReady = true (after OCR/Translation segmentInBatches)');
                    // ====================================
                });
              } else {
                // ========== 渲染完成，解锁 ==========='
                renderingTab = null;
                // ====================================
                // ========== 内容加载完成 =============
                window.contentReady = true;
                console.log('[DEBUG] window.contentReady = true (after OCR/Translation segmentInBatches, no activeContentElement)');
                // ====================================
              }
            }); // End of requestAnimationFrame
          }
        }

        // Start rendering batches and provide a callback for when all are done
        renderBatch(0, () => {
          // This callback is executed after all batches for OCR/Translation are rendered
          console.log(`[showTab - ${tab}] All batches rendered. Proceeding with DOM processing.`);

          // Use requestAnimationFrame to allow browser to paint/layout before further DOM manipulation
          requestAnimationFrame(() => {
            console.log(`[showTab - ${tab}] RAF triggered after all batches rendered.`);
            const currentTabContentWrapper = document.getElementById(contentContainerId);
            if (currentTabContentWrapper) {
                adjustLongHeadingsToParagraphs(currentTabContentWrapper);
            }

            // Now, call segmentInBatches on the fully rendered content
            activeContentElement = document.getElementById(contentContainerId); // Re-affirm activeContentElement
            if (activeContentElement) {
              segmentInBatches(activeContentElement, 10, 50, () => {
                  // This is the onDone callback for segmentInBatches
                  // All segmentation is complete, now apply annotations and listeners
                  if (data && data.annotations && typeof window.applyBlockAnnotations === 'function') {
                      window.applyBlockAnnotations(activeContentElement, data.annotations, contentIdentifier);
                  }
                  // Finally, update Dock stats and TOC as content and structure are finalized
                  if (window.DockLogic && typeof window.DockLogic.updateStats === 'function') {
                    console.log(`[showTab - ${tab}] OCR/Translation: segmentInBatches done, forcing Dock stats update.`);
                    window.DockLogic.updateStats(window.data, currentVisibleTabId);
                  }
                  if (typeof window.refreshTocList === 'function') {
                    console.log(`[showTab - ${tab}] OCR/Translation: segmentInBatches done, forcing TOC refresh.`);
                    window.refreshTocList();
                  }
                  // ========== 渲染完成，解锁 ==========='
                  renderingTab = null;
                  // ====================================
                  // ========== 内容加载完成 =============
                  window.contentReady = true;
                  console.log('[DEBUG] window.contentReady = true (after OCR/Translation segmentInBatches)');
                  // ====================================
              });
            } else {
              // ========== 渲染完成，解锁 ==========='
              renderingTab = null;
              // ====================================
              // ========== 内容加载完成 =============
              window.contentReady = true;
              console.log('[DEBUG] window.contentReady = true (after OCR/Translation segmentInBatches, no activeContentElement)');
              // ====================================
            }
          }); // End of requestAnimationFrame
        });
      }

      // NEW: Adjust long headings. This should be called AFTER innerHTML is set
      // and BEFORE refreshTocList is called.
      // MOVED: adjustLongHeadingsToParagraphs is now called after renderBatch completes for OCR/Translation
      // const tabContentElement = document.getElementById('tabContent');
      // if (tabContentElement) {
      //     adjustLongHeadingsToParagraphs(tabContentElement);
      // }

      // MOVED: refreshTocList is now called later for OCR/Translation
      // if (typeof window.refreshTocList === 'function') {
      //   window.refreshTocList(); // 更新TOC
      // }

      // Update reading progress when tab changes and content is rendered - CALLING DOCK_LOGIC
      if (window.DockLogic && typeof window.DockLogic.forceUpdateReadingProgress === 'function') {
        window.DockLogic.forceUpdateReadingProgress();
      }

      // 如果是分块对比视图，并且按钮存在，则绑定事件
      if (tab === 'chunk-compare') {
        const swapBtn = document.getElementById('swap-chunks-btn');
        if (swapBtn) {
            swapBtn.onclick = function() {
                isOriginalFirstInChunkCompare = !isOriginalFirstInChunkCompare;
                showTab('chunk-compare'); // 重新渲染分块对比视图
            };
        }
      }

      // After tab content is updated, refresh chatbot UI if it's open
      if (window.isChatbotOpen && typeof window.ChatbotUI !== 'undefined' && typeof window.ChatbotUI.updateChatbotUI === 'function') {
        window.ChatbotUI.updateChatbotUI();
      }

      // 应用高亮和批注
      // MOVED: The logic for applying annotations and adding listeners for OCR/Translation
      // is now inside the callback chain starting from renderBatch a few lines above.
      /*
      if ((tab === 'ocr' || tab === 'translation') && contentContainerId) {
        activeContentElement = document.getElementById(contentContainerId);
        if (activeContentElement) {
            // 分批异步分割子块，避免一次性阻塞
            function segmentInBatches(containerElement, batchSize = 10, delay = 50, onDone) {
                const blocks = Array.from(containerElement.children).filter(node => node.nodeType === Node.ELEMENT_NODE);
                let i = 0;
                function runBatch() {
                    const end = Math.min(i + batchSize, blocks.length);
                    for (; i < end; i++) {
                        const el = blocks[i];
                        el.dataset.blockIndex = String(i);
                        if (window.SubBlockSegmenter && typeof window.SubBlockSegmenter.segment === 'function') {
                            window.SubBlockSegmenter.segment(el, i);
                        } else {
                            console.error("SubBlockSegmenter.segment is not available.");
                        }
                    }
                    if (i < blocks.length) {
                        setTimeout(runBatch, delay);
                    } else {
                        // 所有父块的子块分割完成
                        onDone && onDone();
                    }
                }
                runBatch();
            }

            segmentInBatches(activeContentElement, 10, 50, () => {
                // 所有分割完成后，应用批注和监听器
                if (data && data.annotations && typeof window.applyBlockAnnotations === 'function') {
                    window.applyBlockAnnotations(activeContentElement, data.annotations, window.globalCurrentContentIdentifier);
                }
                // **** 新增：在所有子块分割和批注应用完成后，再次更新Dock统计 ****
                if (window.DockLogic && typeof window.DockLogic.updateStats === 'function') {
                  console.log(`[showTab - ${tab}] OCR/Translation content and annotations processed, forcing Dock stats update.`);
                  window.DockLogic.updateStats(window.data, currentVisibleTabId);
                }
                // TOC refresh will be handled later
            });
        }
      } else if (tab === 'chunk-compare') {
      */
      // The chunk-compare logic for annotations and Dock stats remains, as it has its own processing path.
      // We only moved the OCR/Translation specific part.
      if (tab === 'chunk-compare') { // This is the original start of the else if block
         // 对于分块对比视图，为每个原文和译文块单独处理
         setTimeout(() => { //确保DOM更新完毕
            const ocrContentAreas = document.querySelectorAll('.chunk-compare-container .align-block-ocr .align-content.markdown-body');
            const transContentAreas = document.querySelectorAll('.chunk-compare-container .align-block-trans .align-content.markdown-body');
            let areasProcessed = 0;
            const totalAreasToProcess = ocrContentAreas.length + transContentAreas.length;

            function singleAreaProcessed() {
                areasProcessed++;
                if (areasProcessed === totalAreasToProcess) {
                    // 所有分块对比区域处理完毕后更新Dock统计和TOC
                    if (window.DockLogic && typeof window.DockLogic.updateStats === 'function') {
                        console.log(`[showTab - ${tab}] Chunk-compare: all areas processed, forcing Dock stats update.`);
                        window.DockLogic.updateStats(window.data, currentVisibleTabId);
                    }
                    if (typeof window.refreshTocList === 'function') {
                        console.log(`[showTab - ${tab}] Chunk-compare: all areas processed, forcing TOC refresh.`);
                        window.refreshTocList();
                    }
                }
            }

            function processContentAreaAsync(area, isOcrArea, callback) { // Renamed for clarity
                if (!area.id) {
                    area.id = 'chunk-content-' + _page_generateUUID();
                }
                const effectiveContentIdentifier = isOriginalFirstInChunkCompare ? (isOcrArea ? 'ocr' : 'translation') : (isOcrArea ? 'translation' : 'ocr');
                const blockElements = Array.from(area.children).filter(node => node.nodeType === Node.ELEMENT_NODE);

                let i = 0;
                const batchSize = 5;
                function runChunkSubBatch() {
                    const end = Math.min(i + batchSize, blockElements.length);
                    for (; i < end; i++) {
                        const element = blockElements[i];
                        element.dataset.blockIndex = String(i);
                        if (typeof window.SubBlockSegmenter !== 'undefined' && typeof window.SubBlockSegmenter.segment === 'function') {
                            window.SubBlockSegmenter.segment(element, i);
                        } else {
                            console.error("SubBlockSegmenter.segment is not available for chunk processing.");
                        }
                    }
                    if (i < blockElements.length) {
                        setTimeout(runChunkSubBatch, 20);
                    } else {
                        if (data && data.annotations && typeof window.applyBlockAnnotations === 'function') {
                            const annotationsToApply = (currentVisibleTabId === 'chunk-compare') ? [] : data.annotations;
                            window.applyBlockAnnotations(area, annotationsToApply, effectiveContentIdentifier);
                        }
                        callback(); // Signal completion for this area
                    }
                }
                runChunkSubBatch();
            }

            if (totalAreasToProcess === 0) { // Handle case with no content areas
                 if (window.DockLogic && typeof window.DockLogic.updateStats === 'function') {
                    console.log(`[showTab - ${tab}] Chunk-compare has no content areas, forcing Dock stats update.`);
                    window.DockLogic.updateStats(window.data, currentVisibleTabId);
                }
                // TOC refresh will be handled later -> Actually, should be called here too if no areas.
                if (typeof window.refreshTocList === 'function') {
                    console.log(`[showTab - ${tab}] Chunk-compare has no content areas, forcing TOC refresh.`);
                    window.refreshTocList();
                }
            } else {
                ocrContentAreas.forEach(area => processContentAreaAsync(area, true, singleAreaProcessed));
                transContentAreas.forEach(area => processContentAreaAsync(area, false, singleAreaProcessed));
            }
         }, 0);
         // ========== 渲染完成，解锁 ===========
         renderingTab = null;
         // ====================================
      }

      // Attempt to restore scroll position for the current tab
      if (docIdForLocalStorage && currentVisibleTabId) {
        const scrollKey = `scrollPos_${docIdForLocalStorage}_${currentVisibleTabId}`;
        const savedScrollTop = localStorage.getItem(scrollKey);
        // console.log(`[showTab] Attempting to restore scroll for ${scrollKey} on documentElement. Saved value: ${savedScrollTop}`);
        if (savedScrollTop !== null && !isNaN(parseInt(savedScrollTop, 10))) {
          const scrollableElement = document.documentElement; // Changed from .container
          if (scrollableElement) {
            requestAnimationFrame(() => {
              if(currentVisibleTabId === tab) { // Ensure tab hasn't changed during async operation
                scrollableElement.scrollTop = parseInt(savedScrollTop, 10);
                // console.log(`[showTab] Restored scroll for ${scrollKey} (tab: ${tab}) on documentElement to ${scrollableElement.scrollTop}`);
              }
            });
          }
        }
      }
      // Call updateReadingProgress after potential scroll restoration and content rendering - CALLING DOCK_LOGIC
      if (window.DockLogic && typeof window.DockLogic.forceUpdateReadingProgress === 'function') {
        window.DockLogic.forceUpdateReadingProgress();
      }
      // 性能测试断点 - 总渲染结束
      console.timeEnd('[性能] showTab_总渲染');
    }
    // 绑定tab按钮点击事件
    document.getElementById('tab-ocr').onclick = function() { showTab('ocr'); };
    document.getElementById('tab-translation').onclick = function() { showTab('translation'); };
    // document.getElementById('tab-compare').onclick = function() { showTab('compare'); }; // 点击事件注释掉
    document.getElementById('tab-chunk-compare').onclick = function() { showTab('chunk-compare'); };

    // 页面加载后渲染详情
    renderDetail();

    // 自动恢复 globalCurrentContentIdentifier
    (function restoreContentIdentifierFromLocalStorage() {
      try {
        // 优先用 docIdForLocalStorage，如果没有则尝试从URL获取
        let docId = window.docIdForLocalStorage;
        if (!docId && typeof getQueryParam === 'function') {
          docId = getQueryParam('id');
        }
        if (!docId) return;
        const savedTabKey = `activeTab_${docId}`;
        const savedTab = localStorage.getItem(savedTabKey);
        if (savedTab === 'ocr' || savedTab === 'translation') {
          window.globalCurrentContentIdentifier = savedTab;
          console.log('[auto-restore] 恢复 globalCurrentContentIdentifier =', savedTab);
        }
      } catch (e) {
        // 忽略
      }
    })();

  </script>

</body>
</html>