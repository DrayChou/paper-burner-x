<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>历史详情</title>
  <!-- KaTeX 公式渲染样式 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsmind/style/jsmind.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <link rel="stylesheet" href="css/history_detail.css">
  <style>
    /* NEW DOCK STYLES */
    #bottom-left-dock {
      position: fixed;
      bottom: 15px;
      left: 15px;
      background-color: rgba(255, 255, 255, 0.95); /* UPDATED for more distinct white background */
      border: 1px dashed #94a3b8; /* Keep this border, good for white background */
      color: #334155; /* Keep this text color */
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      z-index: 2000;
      opacity: 0;
      transition: opacity 0.4s ease-in-out, transform 0.2s ease-out, padding 0.2s ease-out, min-width 0.2s ease-out, height 0.2s ease-out;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05); /* UPDATED */
      transform: translateY(10px);
      min-width: 30px;
      height: auto;
    }

    /* TOC 模式选择器样式 */
    .toc-mode-selector {
      display: flex;
      gap: 5px;
      margin: 8px 0;
      padding: 5px;
      background-color: #f5f7fa;
      border-radius: 4px;
      justify-content: center;
    }

    .toc-mode-btn {
      padding: 4px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #fff;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s ease;
    }

    .toc-mode-btn.active {
      background-color: #3b82f6;
      color: white;
      border-color: #2563eb;
    }

    .toc-mode-btn:hover:not(.active) {
      background-color: #f0f4f8;
    }

    /* 设置对话框中的单选按钮样式 */
    .radio-container {
      margin: 10px 0 15px;
    }

    .radio-group {
      margin-bottom: 8px;
      display: flex;
      align-items: center;
    }

    .radio-group input[type="radio"] {
      margin-right: 8px;
    }

    .radio-group label {
      cursor: pointer;
    }

    /* TOC 高亮效果 */
    .toc-highlight {
      animation: toc-highlight-flash 2s ease-out;
    }

    @keyframes toc-highlight-flash {
      0%, 100% { background-color: transparent; }
      50% { background-color: rgba(59, 130, 246, 0.2); }
    }

    /* 转换后的标题样式 */
    .converted-from-heading {
      font-weight: 600;
      margin-top: 1.5em;
      margin-bottom: 0.75em;
      color: #333;
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
    }

    /* TOC 信息提示样式 */
    .toc-info {
      padding: 10px;
      margin: 10px 0;
      background-color: #f8f9fa;
      border-left: 3px solid #3b82f6;
      color: #4b5563;
      font-style: italic;
      border-radius: 0 4px 4px 0;
    }

    #bottom-left-dock.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* Updated styles for dock-info-stack and its new columns */
    #dock-info-stack {
      display: flex;
      flex-direction: row; /* Columns side-by-side */
      gap: 2px; /* Further reduced gap between Label column and Value column */
      align-items: flex-start; /* Align columns at their top */
    }

    .dock-column {
      display: flex;
      flex-direction: column;
      gap: 2px; /* Gap between lines within a column */
    }

    .dock-values-column {
      text-align: right; /* Right-align the values/percentages */
      min-width: 40px; /* Slightly reduced min-width */
    }
    .dock-values-column > div {
      justify-content: flex-end; /* Ensure content within value divs also aligns right if they are flex */
    }

    /* Individual stat items, if they need specific styling for clickability */
    .stat-item-clickable {
      text-decoration: underline;
      cursor: pointer;
    }
    .stat-item-clickable:hover {
      color: #1d4ed8;
    }

    #bottom-left-dock > #dock-info-stack,
    #bottom-left-dock > a,
    #bottom-left-dock > #dock-collapsed-progress-display { /* Added new direct child */
      display: flex;
      align-items: center;
    }

    #dock-stats {
      display: flex;
      gap: 8px; /* Space between highlight and annotation counts */
    }

    #bottom-left-dock a {
      color: #3b82f6; /* Slightly softer blue for links/icons, can be adjusted */
      text-decoration: none;
    }
    #bottom-left-dock a:hover {
      color: #2563eb; /* Darker blue on hover */
    }

    #settings-link i.fa-cog, /* Changed ID */
    #dock-toggle-btn i {
      font-size: 1.2em;
      padding: 3px;
    }
    #dock-toggle-btn {
        margin-left: auto; /* Pushes toggle button to the far right */
        cursor: pointer;
    }

    /* Style for the standalone progress display in collapsed mode */
    /* Ensure it's hidden by default when the dock is NOT collapsed */
    #bottom-left-dock:not(.dock-collapsed) #dock-collapsed-progress-display {
        display: none;
    }

    #dock-collapsed-progress-display {
        /* display: none; */ /* This can be removed if the above :not selector is robust */
        color: #334155; /* Match updated dock text color */
        font-weight: 500;
    }

    /* Collapsed state */
    #bottom-left-dock.dock-collapsed {
      padding: 6px 10px; /* Slightly adjust padding for collapsed state */
      gap: 8px; /* Adjust gap for items in collapsed row */
      /* min-width to allow content to show */
    }

    /* Hide these elements when collapsed */
    #bottom-left-dock.dock-collapsed #dock-info-stack,
    #bottom-left-dock.dock-collapsed #settings-link {
      display: none;
    }

    /* Show and style the specific progress display for collapsed mode */
    #bottom-left-dock.dock-collapsed #dock-collapsed-progress-display {
        display: inline; /* Show it */
    }

    /* This rule is no longer needed as #dock-stats is inside #dock-info-stack which gets hidden */
    /* #bottom-left-dock.dock-collapsed #dock-stats, */

    /* Ensure these are visible in collapsed state - REVISED */
    /* #bottom-left-dock.dock-collapsed #dock-reading-progress, */
    /* #bottom-left-dock.dock-collapsed #settings-link {  */
      /* display: flex; */
      /* align-items: center; */
    /* } */

    /* This rule is no longer needed as #dock-stats is inside #dock-info-stack */
    /* #bottom-left-dock.dock-collapsed #dock-stats span {
        text-decoration: underline;
        cursor: pointer;
    }
    #bottom-left-dock.dock-collapsed #dock-stats span:hover {
        color: #1d4ed8;
    } */

    #bottom-left-dock.dock-collapsed #dock-toggle-btn {
      margin-left: auto; /* Ensure toggle button is pushed to the right if other elements are minimal */
    }

    /* Style for the new sub-blocks, can be adjusted */
    .sub-block {
        display: inline; /* Or inline-block if padding/margin is needed and wrap behavior is desired */
    }

   /* NEW STYLES FOR CENTERING IMAGES AND TABLES from Markdown content */
   .markdown-body img {
     display: block; /* Allows margin auto to work for horizontal centering */
     margin-left: auto;
     margin-right: auto;
     max-width: 100%; /* Ensures image is responsive and doesn't overflow container */
     height: auto;    /* Maintains aspect ratio */
   }

   .markdown-body table {
     display: table;  /* Allows margin auto to work for centering while preserving table layout */
     margin-left: auto;
     margin-right: auto;
     /* width: auto; /* Default for display:table, table will size to its content */
   }

    /* Custom Context Menu Styles (Notion-like) */
    #custom-context-menu {
        background-color: #fff; /* White background */
        border: 1px solid #eee; /* Light border */
        border-radius: 8px; /* Rounded corners */
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* Softer shadow */
        padding: 6px 0; /* Vertical padding */
        min-width: 220px; /* Minimum width */
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        font-size: 14px;
        color: #333; /* Darker text color */
        z-index: 10000; /* Ensure it's on top */
    }

    #custom-context-menu ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    #custom-context-menu li {
        padding: 8px 12px; /* Padding for items */
        cursor: pointer;
        display: flex;
        align-items: center;
        transition: background-color 0.15s ease-in-out;
    }

    #custom-context-menu li:hover {
        background-color: #f5f5f5; /* Light gray hover */
    }

    #custom-context-menu li i.fa { /* Icon styling */
        margin-right: 10px;
        color: #555;
        width: 16px; /* Fixed width for alignment */
        text-align: center;
    }

    #custom-context-menu .color-palette {
        display: flex;
        align-items: center;
        margin-left: auto; /* Push color palette to the right */
        padding-left: 10px;
    }

    #custom-context-menu .color-option {
        width: 18px;
        height: 18px;
        border-radius: 50%; /* Circular color options */
        margin-left: 6px;
        cursor: pointer;
        border: 1px solid rgba(0,0,0,0.1);
        transition: transform 0.1s ease-out;
    }
    #custom-context-menu .color-option:hover {
        transform: scale(1.15);
    }

    /* Specific color styles - ensure these match your JS color names */
    .color-yellow { background-color: yellow; }
    .color-pink { background-color: pink; }
    .color-lightblue { background-color: lightblue; }
    .color-lightgreen { background-color: lightgreen; }
    .color-purple { background-color: purple; }
    .color-orange { background-color: orange; }

    /* Divider style */
    #custom-context-menu hr.menu-divider {
        border: none;
        border-top: 1px solid #eee;
        margin: 6px 0;
    }

    /* Add underline and pointer to stats in EXPANDED mode as well */
    /* This is now handled by .stat-item-clickable on the specific spans */
    /* #bottom-left-dock:not(.dock-collapsed) #dock-stats span {
        text-decoration: underline;
        cursor: pointer;
    }
    #bottom-left-dock:not(.dock-collapsed) #dock-stats span:hover {
        color: #1d4ed8;
    } */

    /* Annotations Summary Modal CSS */
    #annotations-summary-modal .modal-content {
      max-width: 80%;
      width: 950px;
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    #annotations-summary-modal .modal-close-btn {
      position: absolute;
      top: 12px;
      right: 18px;
      font-size: 2em;
      color: #888;
      cursor: pointer;
      z-index: 10;
      background: none;
      border: none;
      line-height: 1;
      padding: 0;
      transition: color 0.2s;
    }
    #annotations-summary-modal .modal-close-btn:hover {
      color: #333;
    }
    #annotations-summary-modal .table-container {
      overflow-y: auto;
      flex-grow: 1;
      margin-top: 15px;
      border: 1px solid #e0e0e0; /* Added border for definition */
    }

    #annotations-summary-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    #annotations-summary-table th,
    #annotations-summary-table td {
      border: 1px solid #ddd;
      padding: 10px 8px; /* Adjusted padding */
      text-align: left;
      vertical-align: top;
      word-break: break-word; /* Help with long content */
    }

    #annotations-summary-table th {
      background-color: #f7f7f7; /* Lighter background for header */
      position: sticky;
      top: 0;
      z-index: 1;
      font-weight: 600; /* Bolder header text */
    }

    #annotations-summary-table .color-swatch {
      display: inline-block;
      width: 18px; /* Slightly larger */
      height: 18px; /* Slightly larger */
      border: 1px solid #ccc;
      border-radius: 4px; /* Rounded corners */
      vertical-align: middle;
      box-shadow: 0 0 2px rgba(0,0,0,0.1); /* Subtle shadow */
    }

    #annotations-summary-table .action-btn {
      padding: 5px 10px; /* Adjusted padding */
      font-size: 12px;
      cursor: pointer;
      border: 1px solid #007bff; /* Blue border */
      background-color: #fff; /* White background */
      color: #007bff; /* Blue text */
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    #annotations-summary-table .action-btn:hover {
      background-color: #007bff; /* Blue background on hover */
      color: #fff; /* White text on hover */
    }
    #annotations-summary-table .action-btn:disabled {
      border-color: #ccc;
      background-color: #f0f0f0;
      color: #aaa;
      cursor: not-allowed;
    }

    .annotations-summary-controls {
      margin-bottom: 15px;
      display: flex;
      gap: 20px;
      align-items: center;
      padding: 10px;
      background-color: #f9f9f9;
      border-radius: 4px;
      border: 1px solid #e0e0e0;
      flex-wrap: wrap;
    }
    .annotations-summary-controls label {
      margin-right: 5px;
      font-weight: 500;
    }
    .annotations-summary-controls select {
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      background-color: #fff;
    }
    .annotations-summary-color-filter {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: 10px;
      flex-wrap: wrap;
    }
    .annotations-summary-color-checkbox {
      display: flex;
      align-items: center;
      gap: 2px;
      margin-right: 6px;
      cursor: pointer;
    }
    .annotations-summary-color-checkbox input[type="checkbox"] {
      margin: 0 2px 0 0;
      accent-color: #007bff;
    }
    .annotations-summary-color-swatch {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid #bbb;
      display: inline-block;
      margin-right: 2px;
    }
    /* Temporary highlight for jumped-to element */
    .jump-to-highlight-effect { /* Renamed for clarity */
      transition: background-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
      background-color: rgba(255, 220, 0, 0.45) !important; /* Softer yellow, more transparent */
      box-shadow: 0 0 12px rgba(255, 220, 0, 0.6) !important; /* Softer glow */
      border-radius: 5px !important; /* Smoother radius */
      outline: 2px solid rgba(255, 200, 0, 0.7); /* Added outline */
    }

    /* 批注详情模态框增强样式 */
    #annotations-summary-table td {
      max-width: 250px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #annotations-summary-table td:nth-child(4) {
      cursor: pointer;
      position: relative;
    }

    #annotations-summary-table td:nth-child(4):hover {
      background-color: #f0f0f0;
    }

    #annotations-summary-table td:nth-child(4)::after {
      content: "👁️";
      position: absolute;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0;
      transition: opacity 0.2s;
    }

    #annotations-summary-table td:nth-child(4):hover::after {
      opacity: 0.7;
    }

    /* 文本片段预览对话框样式 */
    .full-text-dialog {
      animation: fadeIn 0.2s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -48%); }
      to { opacity: 1; transform: translate(-50%, -50%); }
    }

    .full-text-dialog button {
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .full-text-dialog button:hover {
      background-color: #e0e0e0;
    }

    /* 颜色筛选区域样式增强 */
    .annotations-summary-color-filter {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: 10px;
      flex-wrap: wrap;
      padding: 5px;
      border: 1px solid #eee;
      border-radius: 4px;
      background-color: #fafafa;
    }

    .annotations-summary-color-checkbox {
      display: flex;
      align-items: center;
      gap: 2px;
      margin-right: 6px;
      cursor: pointer;
      padding: 3px 5px;
      border-radius: 3px;
      transition: background-color 0.2s;
    }

    .annotations-summary-color-checkbox:hover {
      background-color: #f0f0f0;
    }

    .annotations-summary-color-checkbox input[type="checkbox"] {
      margin: 0 2px 0 0;
      accent-color: #007bff;
    }
  </style>
</head>
<body>
  <!-- NEW DOCK STRUCTURE -->
  <div id="bottom-left-dock">
    <div id="dock-info-stack">
      <div class="dock-column dock-labels-column">
        <div class="dock-stat-item-wrapper-progress">阅读进度:</div>
        <div class="dock-stat-item-wrapper-highlight"><span class="stat-item-clickable" data-stat-type="highlight">高亮: <span id="highlight-count">0</span></span></div>
        <div class="dock-stat-item-wrapper-img">图片: <span id="image-count">0</span></div>
        <div class="dock-stat-item-wrapper-formula">公式: <span id="formula-count">0</span></div>
      </div>
      <div class="dock-column dock-values-column">
        <div class="dock-stat-item-wrapper-progress"><span id="reading-progress-percentage-verbose">0</span>%</div>
        <div class="dock-stat-item-wrapper-annotation"><span class="stat-item-clickable" data-stat-type="annotation">批注: <span id="annotation-count">0</span></span></div>
        <div class="dock-stat-item-wrapper-tbl">表格: <span id="table-count">0</span></div>
        <div class="dock-stat-item-wrapper-words">总字数: <span id="total-word-count">0</span></div>
      </div>
    </div>
    <span id="dock-collapsed-progress-display"><span id="reading-progress-percentage">0</span>%</span>
    <a href="#" id="settings-link" title="设置"><i class="fa fa-cog"></i></a>
    <a href="#" id="dock-toggle-btn" title="折叠"><i class="fa fa-chevron-down"></i></a>
  </div>

  <!-- ===================== -->
  <!-- 浮动TOC目录按钮及悬浮窗 -->
  <!-- ===================== -->
  <div id="toc-float-btn"><i class="fa fa-list"></i></div>
  <div id="toc-popup" class="toc-popup-hidden">
    <div id="toc-popup-header">
      <span><i class="fa fa-list"></i>目录 / TOC</span>
      <button id="toc-popup-close-btn">关闭</button>
    </div>
    <ul id="toc-list"></ul>
  </div>

  <!-- ===================== -->
  <!-- 主内容容器 -->
  <!-- ===================== -->
  <div class="container">
    <h2 id="fileName">历史详情</h2>
    <div class="meta" id="fileMeta"></div>

    <!-- 标签页导航 -->
    <div class="tabs-container">
      <button class="tab-btn" id="tab-ocr">仅OCR</button>
      <button class="tab-btn" id="tab-translation">仅翻译</button>
      <!-- <button class="tab-btn" id="tab-compare">对比</button> -->
      <button class="tab-btn" id="tab-chunk-compare">分块对比</button>
    </div>
    <!-- 标签页内容显示区域 -->
    <div class="tab-content" id="tabContent"></div>
  </div>

  <!-- ===================== -->
  <!-- 自定义上下文菜单 -->
  <!-- ===================== -->
  <div id="custom-context-menu" class="context-menu-hidden">
    <ul>
      <li data-action="highlight-block">
        高亮此区块
        <div class="color-palette">
          <span class="color-option color-yellow" data-color="yellow" title="黄色"></span>
          <span class="color-option color-pink" data-color="pink" title="粉色"></span>
          <span class="color-option color-lightblue" data-color="lightblue" title="浅蓝色"></span>
          <span class="color-option color-lightgreen" data-color="lightgreen" title="浅绿色"></span>
          <span class="color-option color-purple" data-color="purple" title="紫色"></span>
          <span class="color-option color-orange" data-color="orange" title="橙色"></span>
        </div>
      </li>
      <li data-action="remove-highlight" id="remove-highlight-option" style="display: none;">取消高亮</li>
      <hr class="menu-divider" id="highlight-actions-divider" style="display: none;">
      <li data-action="add-note" id="add-note-option" style="display: none;">添加批注</li>
      <li data-action="edit-note" id="edit-note-option" style="display: none;">编辑批注</li>
      <hr class="menu-divider" id="note-actions-divider" style="display: none;">
      <li data-action="copy-content" id="copy-content-option"><i class="fa fa-copy"></i>复制内容</li>
      <!-- 更多操作可以后续添加 -->
    </ul>
  </div>

  <!-- Dock Settings Modal -->
  <div id="dock-settings-modal" class="dock-settings-modal modal-overlay"> <!-- Default: not visible -->
    <div class="dock-settings-modal-content modal-content"> <!-- ADDED modal-content class -->
      <span class="dock-settings-modal-close-btn" id="dock-settings-close-btn">&times;</span>
      <h2>显示设置</h2>
      <div class="checkbox-container"> <!-- Container for checkboxes -->
        <div class="checkbox-group">
          <input type="checkbox" id="ds-readingProgress" data-config-key="readingProgress">
          <label for="ds-readingProgress">阅读进度</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-highlights" data-config-key="highlights">
          <label for="ds-highlights">高亮</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-annotations" data-config-key="annotations">
          <label for="ds-annotations">批注</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-images" data-config-key="images">
          <label for="ds-images">图片</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-tables" data-config-key="tables">
          <label for="ds-tables">表格</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-formulas" data-config-key="formulas">
          <label for="ds-formulas">公式</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-words" data-config-key="words">
          <label for="ds-words">总字数</label>
        </div>
      </div>

      <!-- 新增TOC显示模式设置部分 -->
      <h3>目录(TOC)设置</h3>
      <div class="radio-container">
        <div class="radio-group">
          <input type="radio" id="toc-mode-both" name="toc-mode" value="both" checked>
          <label for="toc-mode-both">双语目录</label>
        </div>
        <div class="radio-group">
          <input type="radio" id="toc-mode-ocr" name="toc-mode" value="ocr">
          <label for="toc-mode-ocr">仅原文目录</label>
        </div>
        <div class="radio-group">
          <input type="radio" id="toc-mode-translation" name="toc-mode" value="translation">
          <label for="toc-mode-translation">仅译文目录</label>
        </div>
      </div>

      <div class="dock-settings-modal-buttons">
        <button id="dock-settings-save-btn" class="btn btn-primary">保存</button>
        <button id="dock-settings-cancel-btn" class="btn btn-secondary">取消</button>
      </div>
    </div>
  </div>

  <!-- Annotations/Highlights Summary Modal -->
  <div id="annotations-summary-modal" class="modal-overlay"> <!-- Default: not visible via CSS -->
    <div class="modal-content">
      <span class="modal-close-btn" id="annotations-summary-close-btn">&times;</span>
      <h2 id="annotations-summary-title">批注与高亮详情</h2>
      <div class="annotations-summary-controls">
        <label for="annotations-filter-type">类型:</label>
        <select id="annotations-filter-type">
          <option value="all">全部</option>
          <option value="highlighting">仅高亮</option>
          <option value="commenting">带批注</option>
        </select>
        <label for="annotations-filter-content">内容来源:</label>
        <select id="annotations-filter-content">
          <option value="all">全部 (OCR/翻译)</option>
          <option value="ocr">仅 OCR</option>
          <option value="translation">仅翻译</option>
        </select>
        <div class="annotations-summary-color-filter" id="annotations-summary-color-filter">
          <!-- 动态插入颜色多选 -->
        </div>
      </div>
      <div class="table-container">
        <table id="annotations-summary-table">
          <thead>
            <tr>
              <th>类型</th>
              <th>来源</th>
              <th>标识符</th>
              <th>文本片段 (预览)</th>
              <th>笔记</th>
              <th>颜色</th>
              <th>操作</th>
            </tr>
          </thead>
          <tbody id="annotations-summary-table-body">
            <!-- Rows will be populated by JavaScript -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- ===================== -->
  <!-- 依赖的JS库 -->
  <!-- ===================== -->
  <script src="js/storage.js"></script>
  <script src="js/annotation_logic.js"></script>       <!-- Defines helpers like checkIfTextIsHighlighted -->
  <script src="js/custom_markdown_renderer.js"></script> <!-- Defines createCustomMarkdownRenderer -->
  <script src="js/annotation_highlighter.js"></script>   <!-- Defines applyPreprocessedAnnotations, uses helpers from annotation_logic.js -->
  <script src="js/toc_logic.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2pdf.js@0.10.1/dist/html2pdf.bundle.min.js"></script>
  <script src="js/mindmap.js"></script>

  <script src="js/chatbot/prompt-constructor.js"></script> <!-- Add this line -->
  <script src="js/chatbot/chatbot-utils.js"></script>
  <script src="js/chatbot/chatbot-preset.js"></script>
  <script src="js/chatbot/chatbot-core.js"></script>
  <script src="js/chatbot/chatbot-ui.js"></script>
  <script src="js/chatbot/chatbot.js"></script>
  <script src="js/dock_logic.js"></script>
  <script src="js/markdown_processor.js"></script>
  <script src="js/sub_block_segmenter.js"></script>
  <script src="js/dock_settings_modal.js"></script> <!-- ADDED -->
  <script src="js/annotations_summary_modal.js"></script> <!-- ADDED -->

  <!-- ===================== -->
  <!-- 页面核心逻辑脚本 -->
  <!-- ===================== -->
  <script>
    let isOriginalFirstInChunkCompare = true; // 状态变量：原文是否在左侧
    let docIdForLocalStorage = null; // To store the current document ID for localStorage keys
    window.docIdForLocalStorage = null; // 将变量挂载到 window 对象上，使其成为全局变量
    var currentVisibleTabId = null;  // To store the ID of the currently visible tab
    window.currentVisibleTabId = null; // 将变量挂载到 window 对象上，使其成为全局变量
    // let progressPercentageSpan = null; // MOVED to dock_logic.js
    // let progressPercentageVerboseSpan = null; // MOVED to dock_logic.js
    // let dockElement = null; // MOVED to dock_logic.js

    // NEW FUNCTION DEFINITION
    function adjustLongHeadingsToParagraphs(parentElement) {
      if (!parentElement) return;

      // Only process headings within elements having 'markdown-body' class
      const markdownBodies = parentElement.querySelectorAll('.markdown-body');

      markdownBodies.forEach(markdownBody => {
        const headings = markdownBody.querySelectorAll('h1, h2, h3, h4, h5, h6');
        headings.forEach(heading => {
          // Skip the main fileName heading if it's somehow caught by this logic
          if (heading.id === 'fileName') {
              return;
          }

          const textContent = heading.textContent || "";
          if (textContent.length > 30) {
            const p = document.createElement('p');

            // Move all child nodes from heading to p
            while (heading.firstChild) {
              p.appendChild(heading.firstChild);
            }

            // Copy all attributes from heading to p
            for (let i = 0; i < heading.attributes.length; i++) {
              const attr = heading.attributes[i];
              p.setAttribute(attr.name, attr.value);
            }

            // Add a class to indicate this was a converted heading,
            // in case specific styling is needed later.
            p.classList.add('converted-from-heading');

            // Replace the heading with the new paragraph element in the DOM
            if (heading.parentNode) {
              heading.parentNode.replaceChild(p, heading);
            }
          }
        });
      });
    }

    function debounce(func, delay) {
      let timeout;
      return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), delay);
      };
    }

    function saveScrollPosition() {
      if (!docIdForLocalStorage || !currentVisibleTabId) return;
      const scrollableElement = document.documentElement; // Changed from .container
      if (scrollableElement) {
        const scrollKey = `scrollPos_${docIdForLocalStorage}_${currentVisibleTabId}`;
        localStorage.setItem(scrollKey, scrollableElement.scrollTop);
        // console.log(`Saved scroll for ${scrollKey} on documentElement: ${scrollableElement.scrollTop}`);
      }
    }
    // const debouncedSaveScrollPosition = debounce(saveScrollPosition, 300); // Debounce with 300ms
    const debouncedSaveScrollPosition = debounce(saveScrollPosition, 300); // 取消注释，修复问题

    function saveChatbotStateOnUnload() {
      if (docIdForLocalStorage && typeof window.isChatbotOpen !== 'undefined') {
        localStorage.setItem(`chatbotOpenState_${docIdForLocalStorage}`, window.isChatbotOpen);
        // console.log(`Saved chatbot state on beforeunload for ${docIdForLocalStorage}: ${window.isChatbotOpen}`);
      }
    }

    // MOVED to dock_logic.js: function updateReadingProgress() { ... }
    // MOVED to dock_logic.js: const debouncedUpdateReadingProgress = debounce(updateReadingProgress, 100);

    // MOVED to dock_logic.js: function updateHighlightSummary() { ... }
    // MOVED to dock_logic.js: function updateAnnotationSummary() { ... }
    // MOVED to dock_logic.js: function updateImageCount() { ... }
    // MOVED to dock_logic.js: function updateTableCount(contentElement) { ... }
    // MOVED to dock_logic.js: function updateFormulaCount(contentElement) { ... }
    // MOVED to dock_logic.js: function updateWordCount(contentElement) { ... }
    // MOVED to dock_logic.js: function updateAllDockStats() { ... }

    /**
     * 预处理 Markdown 文本，以安全地渲染图片、自定义语法（如上下标）并兼容 KaTeX。
     * - 将 Markdown 中的本地图片引用 (e.g., `![alt](images/img-1.jpeg.png)`) 替换为 Base64 嵌入式图片。
     * - 解析自定义的上下标语法 (e.g., `${base}^{sup}$`, `${base}_{sub}$`) 并转换为 HTML `<sup>` 和 `<sub>` 标签。
     * - 其他如 `$formula$` 和 `$$block formula$$` 的 LaTeX 标记会保留，交由后续的 `renderWithKatexFailback` 处理。
     *
     * @param {string} md -输入的 Markdown 文本。
     * @param {Array<Object>} images -一个包含图片对象的数组，每个对象应有 `name` 或 `id` (用于匹配) 和 `data` (Base64 图片数据或其前缀)。
     * @returns {string} 处理后的 Markdown 文本，其中图片被替换，自定义语法被转换。
     */
    // MOVED to js/markdown_processor.js: function safeMarkdown(md, images) { ... }

    /**
     * 使用 KaTeX 渲染 Markdown 文本中的数学公式，并提供降级处理。
     * 它会按以下顺序处理：
     * 1. 将长度较短 (<=10字符) 的块级公式 `$$...$$` 转换为行内公式 `$...\$`。
     * 2. 尝试使用 KaTeX 渲染行内公式 `$...\$`。如果渲染失败，则将公式内容包裹在 `<code>` 标签中显示。
     * 3. 尝试使用 KaTeX 渲染剩余的（通常是多行的）块级公式 `$$...$$`。如果渲染失败，则同样包裹在 `<code>` 标签中。
     * 4. 对处理完公式的文本，使用 `marked.parse()` 将其余 Markdown 内容转换为 HTML。
     *
     * @param {string} md - 经过 `safeMarkdown` 处理的 Markdown 文本。
     * @param {Function} customRenderer - 自定义的 Markdown 渲染器函数，用于处理特殊内容。
     * @returns {string} 包含渲染后公式和其余 Markdown 内容的 HTML 字符串。
     */
    // MOVED to js/markdown_processor.js: function renderWithKatexFailback(md, customRenderer) { ... }

    /**
     * 从当前页面的 URL 中获取指定查询参数的值。
     * @param {string} name - 要获取的查询参数的名称。
     * @returns {string|null} 查询参数的值，如果不存在则返回 null。
     */
    function getQueryParam(name) {
      const url = new URL(window.location.href);
      return url.searchParams.get(name);
    }
    /**
     * @type {Object|null}
     * @description 存储从 IndexedDB 加载的当前历史记录的详细数据。
     */
    let data = null;

    /**
     * 将块级元素内容按标点分割成子块 (span.sub-block)。
     * @param {HTMLElement} blockElement - 要分割的块级元素 (如 p, h1-h6)。
     * @param {string|number} parentBlockIndex - 父块的索引。
     */
    // MOVED to js/sub_block_segmenter.js: function segmentBlockIntoSubBlocks(blockElement, parentBlockIndex) { ... }

    /**
     * 异步渲染历史详情页面的主函数。
     * - 从 URL 查询参数中获取记录 ID。
     * - 使用 `getResultFromDB` (来自 storage.js) 从 IndexedDB 加载对应的历史数据。
     * - 如果数据成功加载：
     *   - 更新页面标题 (`#fileName`) 和元数据 (`#fileMeta`)。
     *   - 根据数据中是否存在有效的分块信息 (`ocrChunks`, `translatedChunks`)，
     *     决定默认显示的标签页（优先显示分块对比，否则显示 OCR 内容）。
     * - 如果未找到数据，则显示提示信息。
     * @async
     */
    async function renderDetail() {
      const id = getQueryParam('id');
      if (!id) return;
      docIdForLocalStorage = id; // Store doc ID for localStorage operations
      window.docIdForLocalStorage = id; // 同时更新挂载到 window 对象上的变量

      // Restore chatbot open state
      const savedChatbotOpenState = localStorage.getItem(`chatbotOpenState_${docIdForLocalStorage}`);
      if (savedChatbotOpenState === 'true') {
        window.isChatbotOpen = true;
      } else if (savedChatbotOpenState === 'false') {
        window.isChatbotOpen = false;
      }

      // 从localStorage恢复保存的比例设置
      const savedChunkCompareRatio = localStorage.getItem(`chunkCompareRatio_${docIdForLocalStorage}`);
      if (savedChunkCompareRatio !== null && !isNaN(parseFloat(savedChunkCompareRatio))) {
        window.chunkCompareRatio = parseFloat(savedChunkCompareRatio);
      }

      // console.log(`Chatbot state after attempting restore from localStorage for ${docIdForLocalStorage}: ${window.isChatbotOpen}`);

      // Initialize Dock Logic once docIdForLocalStorage is available
      if (typeof window.DockLogic !== 'undefined' && typeof window.DockLogic.init === 'function') {
        window.DockLogic.init(docIdForLocalStorage);
      } else {
        console.error("DockLogic not available or init function missing.");
      }

      data = await getResultFromDB(id);
      window.data = data; // for debugging
      if (!data) {
        document.getElementById('fileName').textContent = '未找到数据';
        document.getElementById('fileMeta').textContent = '';
        document.getElementById('tabContent').innerHTML = '';
        return;
      }
      document.getElementById('fileName').textContent = data.name;
      document.getElementById('fileMeta').innerHTML = `时间: ${new Date(data.time).toLocaleString()} &nbsp; | &nbsp; 图片数: ${data.images ? data.images.length : 0}`;

      // ========== 确保批注数据在渲染前加载 ==========
      if (id) { // 确保我们有文档 ID
        try {
          const annotations = await getAnnotationsForDocFromDB(id);
          console.log(`Annotations for docId '${id}' (loaded in renderDetail):`, annotations);
          data.annotations = annotations || []; // 存储到 data 对象，确保是数组
          // updateAnnotationSummary(); // Handled by updateAllDockStats via showTab
          // updateHighlightSummary(); // Handled by updateAllDockStats via showTab
        } catch (error) {
          console.error(`Error loading annotations for docId '${id}' in renderDetail:`, error);
          data.annotations = []; // 出错时也确保是个空数组
          // updateAnnotationSummary(); // Handled by updateAllDockStats via showTab
          // updateHighlightSummary(); // Handled by updateAllDockStats via showTab
        }
      } else {
        // updateAnnotationSummary(); // Handled by updateAllDockStats via showTab
        // updateHighlightSummary(); // Handled by updateAllDockStats via showTab
      }
      // =============================================

      // ========== 在 window.data 设置并填充批注后，显式加载聊天记录 ==========
      if (window.data) {
        if (window.ChatbotCore && typeof window.ChatbotCore.reloadChatHistoryAndUpdateUI === 'function' &&
            window.ChatbotUI && typeof window.ChatbotUI.updateChatbotUI === 'function') {
          console.log('renderDetail: Calling reloadChatHistoryAndUpdateUI after window.data and annotations are set. Current docId:', window.ChatbotCore.getCurrentDocId ? window.ChatbotCore.getCurrentDocId() : 'unknown');
          window.ChatbotCore.reloadChatHistoryAndUpdateUI(window.ChatbotUI.updateChatbotUI);
        } else {
          console.error('renderDetail: ChatbotCore or ChatbotUI not fully available for history reload.');
        }
      }
      // =================================================================

      // Initialize annotation system after data is loaded and DOM is likely ready
      if (typeof window.initializeGlobalAnnotationVariables === 'function') {
        window.initializeGlobalAnnotationVariables();
      }
      if (typeof window.initAnnotationSystem === 'function') {
        window.initAnnotationSystem();
      } else {
        console.error("initAnnotationSystem is not defined. Check js/annotation_logic.js");
      }

      // Determine initial tab, AFTER annotations are loaded
      let initialTab = 'ocr'; // Default tab
      if (docIdForLocalStorage) {
        const savedTabKey = `activeTab_${docIdForLocalStorage}`;
        const savedTab = localStorage.getItem(savedTabKey);
        if (savedTab && ['ocr', 'translation', 'chunk-compare'].includes(savedTab)) {
          initialTab = savedTab;
        } else if (data.ocrChunks && data.ocrChunks.length > 0 && data.translatedChunks && data.translatedChunks.length > 0 && data.ocrChunks.length === data.translatedChunks.length) {
           initialTab = 'chunk-compare';
        }
      } else if (data.ocrChunks && data.ocrChunks.length > 0 && data.translatedChunks && data.translatedChunks.length > 0 && data.ocrChunks.length === data.translatedChunks.length) {
        initialTab = 'chunk-compare';
      }

      // 现在，在批注肯定加载完毕后，才调用 showTab
      showTab(initialTab);

      // The block for loading annotations (previously around line 415) has been moved up.

      // Add scroll listener for saving scroll position
      window.removeEventListener('scroll', debouncedSaveScrollPosition);
      window.addEventListener('scroll', debouncedSaveScrollPosition);
      // Add scroll listener for updating reading progress - MOVED TO DOCK_LOGIC.JS
      // window.removeEventListener('scroll', debouncedUpdateReadingProgress);
      // window.addEventListener('scroll', debouncedUpdateReadingProgress);

      // Add listener to save chatbot state on page unload
      window.removeEventListener('beforeunload', saveChatbotStateOnUnload);
      window.addEventListener('beforeunload', saveChatbotStateOnUnload);

      // Manage Annotations Link Click - Changed to Settings Link - MOVED TO DOCK_LOGIC.JS
      // const settingsLink = document.getElementById('settings-link');
      // if (settingsLink) {
      //   settingsLink.onclick = function(event) {
      //     event.preventDefault();
      //     alert('管理页面即将推出！'); // Updated alert message
      //   };
      // }

      // Dock Toggle Button Click - MOVED TO DOCK_LOGIC.JS
      // const dockToggleBtn = document.getElementById('dock-toggle-btn');
      // const dock = document.getElementById('bottom-left-dock');
      // if (dockToggleBtn && dock) {
      //   // Restore collapsed state
      //   const dockCollapsedKey = `dockCollapsed_${docIdForLocalStorage}`;
      //   const isCollapsed = localStorage.getItem(dockCollapsedKey) === 'true';
      //   if (isCollapsed) {
      //     dock.classList.add('dock-collapsed');
      //     dockToggleBtn.innerHTML = '<i class="fa fa-chevron-up"></i>';
      //     dockToggleBtn.title = '展开';
      //   }

      //   dockToggleBtn.onclick = function(event) {
      //     event.preventDefault();
      //     const currentlyCollapsed = dock.classList.toggle('dock-collapsed');
      //     if (currentlyCollapsed) {
      //       this.innerHTML = '<i class="fa fa-chevron-up"></i>';
      //       this.title = '展开';
      //       localStorage.setItem(dockCollapsedKey, 'true');
      //     } else {
      //       this.innerHTML = '<i class="fa fa-chevron-down"></i>';
      //       this.title = '折叠';
      //       localStorage.setItem(dockCollapsedKey, 'false');
      //     }
      //   };
      // }
    }

    /**
     * 切换并显示指定的标签页内容。
     * - 更新标签按钮的激活状态 (`active` class)。
     * - 根据传入的 `tab` 参数 ( 'ocr', 'translation', 'chunk-compare' )，生成对应的 HTML 内容。
     * - OCR 和翻译标签页：直接渲染 `data.ocr` 或 `data.translation` 字段。
     * - 分块对比标签页 (`chunk-compare`)：
     *   - 检查 `data.ocrChunks` 和 `data.translatedChunks` 是否有效且数量匹配。
     *   - 如果有效，则为每一对原文/译文块生成对比视图。使用 `renderLevelAlignedFlex` 进行布局。
     *   - 提供一个按钮 (`#swap-chunks-btn`) 用于切换原文和译文在对比视图中的左右位置。
     *   - 如果分块数据无效，则显示提示信息。
     * - 将生成的 HTML 设置到 `#tabContent` 区域。
     * - 调用 `window.refreshTocList()` 更新目录（TOC）。
     *
     * @param {string} tab - 要显示的标签页标识符 ('ocr', 'translation', or 'chunk-compare')。
     */
    function showTab(tab) {
      currentVisibleTabId = tab; // Update global current tab ID
      window.currentVisibleTabId = tab; // 同时更新挂载到 window 对象上的变量
      window.currentBlockTokensForCopy = window.currentBlockTokensForCopy || {}; // Initialize if not exists

      // 根据 tab 参数立即设置全局内容标识符
      if (tab === 'ocr') {
        window.globalCurrentContentIdentifier = 'ocr';
      } else if (tab === 'translation') {
        window.globalCurrentContentIdentifier = 'translation';
      } else {
        window.globalCurrentContentIdentifier = ''; // 例如分块对比或其他标签页
      }

      if (docIdForLocalStorage) {
        const activeTabKey = `activeTab_${docIdForLocalStorage}`;
        localStorage.setItem(activeTabKey, tab);
        // console.log(`Saved active tab for ${docIdForLocalStorage}: ${tab}`);
      }

      document.getElementById('tab-ocr').classList.remove('active');
      document.getElementById('tab-translation').classList.remove('active');
      // document.getElementById('tab-compare').classList.remove('active'); // 对应按钮已注释，此行也可注释
      document.getElementById('tab-chunk-compare').classList.remove('active');

      let html = '';
      let contentContainerId = ''; // 用于 applyAnnotationsToContent
      let activeContentElement = null; // 用于 applyAnnotationsToContent
      const significantTokenTypes = ['paragraph', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'hr'];

      // ---- 增加日志 ----
      // 日志现在可以准确反映 globalCurrentContentIdentifier
      console.log(`[showTab - ${tab}] 即将渲染。当前 window.globalCurrentContentIdentifier:`, window.globalCurrentContentIdentifier);
      if (data && data.annotations) {
          console.log(`[showTab - ${tab}] data.annotations (长度 ${data.annotations.length}):`, JSON.parse(JSON.stringify(data.annotations)));
      } else {
          console.log(`[showTab - ${tab}] data.annotations 不可用或为空。`);
      }
      // ---- 日志结束 ----

      if(tab === 'ocr') {
        document.getElementById('tab-ocr').classList.add('active');
        contentContainerId = 'ocr-content-wrapper';
        let ocrText = data.ocr || '';
        const ocrLexerTokens = marked.lexer(ocrText);
        window.currentBlockTokensForCopy['ocr'] = ocrLexerTokens.filter(token => significantTokenTypes.includes(token.type));
        const ocrCustomRenderer = createCustomMarkdownRenderer(data.annotations, 'ocr', MarkdownProcessor.renderWithKatexFailback); // MODIFIED
        const ocrContentHTML = MarkdownProcessor.renderWithKatexFailback(MarkdownProcessor.safeMarkdown(ocrText, data.images), ocrCustomRenderer); // MODIFIED
        html = `<h3>OCR内容</h3><div id="${contentContainerId}" class="markdown-body content-wrapper">${ocrContentHTML}</div>`;
      } else if(tab === 'translation') {
        document.getElementById('tab-translation').classList.add('active');
        contentContainerId = 'translation-content-wrapper';
        let transText = data.translation || '';
        const transLexerTokens = marked.lexer(transText);
        window.currentBlockTokensForCopy['translation'] = transLexerTokens.filter(token => significantTokenTypes.includes(token.type));
        const translationCustomRenderer = createCustomMarkdownRenderer(data.annotations, 'translation', MarkdownProcessor.renderWithKatexFailback); // MODIFIED
        const translationContentHTML = MarkdownProcessor.renderWithKatexFailback(MarkdownProcessor.safeMarkdown(transText, data.images), translationCustomRenderer); // MODIFIED
        html = `<h3>翻译内容</h3><div id="${contentContainerId}" class="markdown-body content-wrapper">${translationContentHTML}</div>`;
      } else if (tab === 'chunk-compare') {
        // window.globalCurrentContentIdentifier = ''; // 已在函数开头正确设置
        document.getElementById('tab-chunk-compare').classList.add('active');
        if (data.ocrChunks && data.ocrChunks.length > 0 && data.translatedChunks && data.translatedChunks.length === data.ocrChunks.length) {
            html = `
              <div class="chunk-compare-title-bar">
                <h3>分块对比</h3>
                <button id="swap-chunks-btn" title="切换原文/译文位置">⇆</button>
              </div>
              <div class="chunk-compare-container">
            `;
            /**
             * 解析Markdown文本为逻辑块数组，主要基于标题进行分割。
             * 代码块 (```...```) 会被视为单个块的一部分，不会被分割。
             * @param {string} md - Markdown文本。
             * @returns {Array<Object>} 每个对象包含 `{ content: string }`。
             */
            function parseMarkdownBlocks(md) {
              const lines = (md || '').split(/\r?\n/);
              const blocks = [];
              let buffer = [];
              let inCode = false;
              let isFirstBlock = true;
              function flush() {
                if (buffer.length) {
                  blocks.push({ content: buffer.join('\n') });
                  buffer = [];
                }
              }
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (/^\s*```/.test(line)) { // 代码块
                  inCode = !inCode;
                  buffer.push(line);
                  continue;
                }
                if (inCode) {
                  buffer.push(line);
                  continue;
                }
                if (/^\s*#/.test(line)) { // 标题作为新分块的起点
                  if (!isFirstBlock) flush();
                  isFirstBlock = false;
                  buffer.push(line);
                  continue;
                }
                // 普通内容、列表、空行等都合并到当前块
                buffer.push(line);
              }
              flush();
              return blocks;
            }
            /**
             * 对齐两组Markdown逻辑块，用于并排显示。
             * 简单地按索引逐个配对，如果某一组块少，则对应位置为空字符串。
             * @param {Array<Object>} blocks1 - 第一组块。
             * @param {Array<Object>} blocks2 - 第二组块。
             * @returns {Array<Array<string>>} 每个内部数组包含两个字符串 `[block1_content, block2_content]`。
             */
            function alignBlocks(blocks1, blocks2) {
              // 简单按类型和顺序对齐
              const maxLen = Math.max(blocks1.length, blocks2.length);
              const aligned = [];
              for (let i = 0; i < maxLen; i++) {
                aligned.push([
                  blocks1[i] ? blocks1[i].content : '',
                  blocks2[i] ? blocks2[i].content : ''
                ]);
              }
              return aligned;
            }
            /**
             * 渲染单个OCR块和其对应的翻译块的对齐视图，支持分层结构。
             * - 它首先使用 `parseMarkdownBlocks` 将OCR和翻译文本分割成小块（基于标题）。
             * - 然后使用 `alignBlocks` 对齐这些小块。
             * - 为每个对齐的小块对生成并排的HTML结构，用于显示原文和译文。
             * - 提供工具栏按钮，用于切换显示模式（对比、仅原文、仅译文）、复制整块内容以及导航到上下块。
             * - 原始块内容存储在 `window.blockRawContent_[blockIndex]` 中，供复制功能使用。
             *
             * @param {string} ocrChunk - OCR文本块。
             * @param {string} translatedChunk - 对应的翻译文本块。
             * @param {Array<Object>} images - 与此文档关联的图片数据。
             * @param {number} blockIndex - 当前大块在整个文档分块中的索引。
             * @param {number} totalBlocks - 文档分块的总数。
             * @returns {string} 生成的HTML字符串，用于显示对齐的块内容。
             */
            function renderLevelAlignedFlex(ocrChunk, translatedChunk, images, blockIndex, totalBlocks) {
              const ocrBlocks = parseMarkdownBlocks(ocrChunk);
              const transBlocks = parseMarkdownBlocks(translatedChunk);
              const aligned = alignBlocks(ocrBlocks, transBlocks);
              let showMode = window[`showMode_block_${blockIndex}`] || 'both';

              // 在分块对比内部也尝试使用自定义渲染器
              // 注意：这里的 annotations 应该是整个文档的，contentIdentifier 需要根据当前块是原文还是译文来确定
              // 为了简化，我们暂时假设分块对比中的内容不直接参与这种精细的预标注，
              // 或者需要更复杂的逻辑来传递正确的 contentIdentifier
              // MODIFIED: Pass empty array for annotations in chunk-compare mode to disable highlights/annotations
              const annotationsForChunkRender = [];
              const ocrRenderer = createCustomMarkdownRenderer(annotationsForChunkRender, 'ocr', MarkdownProcessor.renderWithKatexFailback);
              const transRenderer = createCustomMarkdownRenderer(annotationsForChunkRender, 'translation', MarkdownProcessor.renderWithKatexFailback);

              // 整块复制按钮
              let html = `
                <div class="block-toolbar" data-block-toolbar="${blockIndex}">
                  <div class="block-toolbar-left">
                    <span class="block-mode-btn ${showMode === 'both' ? 'active' : ''}" data-mode="both" data-block="${blockIndex}">对比</span>
                    <span class="block-mode-btn ${showMode === 'ocr' ? 'active' : ''}" data-mode="ocr" data-block="${blockIndex}">原文</span>
                    <span class="block-mode-btn ${showMode === 'trans' ? 'active' : ''}" data-mode="trans" data-block="${blockIndex}">译文</span>
                    <button class="block-copy-btn" data-block="${blockIndex}" title="复制本块内容">复制本块</button>
                  </div>
                  <div class="block-toolbar-right">
                    ${blockIndex > 0 ? `<button class="block-nav-btn" data-dir="prev" data-block="${blockIndex}" title="上一段">↑</button>` : ''}
                    ${blockIndex < totalBlocks-1 ? `<button class="block-nav-btn" data-dir="next" data-block="${blockIndex}" title="下一段">↓</button>` : ''}
                  </div>
                </div>
              `;
              for (let i = 0; i < aligned.length; i++) {
                html += `
                  <div class="align-flex block-flex block-flex-${blockIndex} ${showMode==='ocr'?'block-mode-ocr-only':showMode==='trans'?'block-mode-trans-only':'block-mode-both'}" data-block="${blockIndex}" data-align-index="${i}">
                    <div class="align-block align-block-ocr">
                      <div class="align-title">
                        <span>原文</span>
                        <button class="block-struct-copy-btn" data-block="${blockIndex}" data-type="ocr" data-idx="${i}" title="复制原文结构">复制</button>
                      </div>
                      <div class="align-content markdown-body">${MarkdownProcessor.renderWithKatexFailback(MarkdownProcessor.safeMarkdown(aligned[i][0], images), isOriginalFirstInChunkCompare ? ocrRenderer : transRenderer)}</div>
                    </div>
                    <div class="splitter" title="拖动调整比例"></div>
                    <div class="align-block align-block-trans">
                      <div class="align-title">
                        <span>译文</span>
                        <button class="block-struct-copy-btn" data-block="${blockIndex}" data-type="trans" data-idx="${i}" title="复制译文结构">复制</button>
                      </div>
                      <div class="align-content markdown-body">${MarkdownProcessor.renderWithKatexFailback(MarkdownProcessor.safeMarkdown(aligned[i][1], images), isOriginalFirstInChunkCompare ? transRenderer : ocrRenderer)}</div>
                    </div>
                  </div>
                `;
              }
              // 记录原始内容，供复制用
              window[`blockRawContent_${blockIndex}`] = aligned;
              return html;
            }
            // 渲染每个分块，增加唯一id
            for (let i = 0; i < data.ocrChunks.length; i++) {
                const ocrChunk = data.ocrChunks[i] || '';
                const translatedChunk = data.translatedChunks[i] || '';
                let blockHtmlToRender;
                let outerBlockTitle;

                if (isOriginalFirstInChunkCompare) {
                    // 当原文在左侧时，调用 renderLevelAlignedFlex(原文, 译文)
                    // window[`blockRawContent_${i}`] 将存储 [原文子块, 译文子块]
                    blockHtmlToRender = renderLevelAlignedFlex(ocrChunk, translatedChunk, data.images, i, data.ocrChunks.length);
                    outerBlockTitle = `原文块 ${i+1}`;
                } else {
                    // 当译文在左侧时，调用 renderLevelAlignedFlex(译文, 原文)
                    // window[`blockRawContent_${i}`] 将存储 [译文子块, 原文子块]
                    blockHtmlToRender = renderLevelAlignedFlex(translatedChunk, ocrChunk, data.images, i, data.ocrChunks.length);
                    outerBlockTitle = `译文块 ${i+1}`; // 标题也反映左侧内容
                }
                html += `<div class="chunk-pair">`;
                html += `<div id="block-${i}" class="block-outer">`; // id 用于导航
                html += `<h4>${outerBlockTitle}</h4>`;
                html += blockHtmlToRender;
                html += `</div></div>`;
            }
            html += '</div>';
            // 绑定每个分块的切换按钮和导航按钮事件
            setTimeout(() => {
              // 拖动分割条实现 - 使用CSS变量而不是直接设置样式
              let ratio = window.chunkCompareRatio;
              if (typeof ratio !== 'number' || isNaN(ratio)) ratio = 0.5;
              window.chunkCompareRatio = ratio; // 确保全局变量被设置

              function applyRatioToAll() {
                const currentRatio = window.chunkCompareRatio || 0.5;
                document.querySelectorAll('.align-flex').forEach(flex => {
                  // 使用CSS变量而不是直接设置样式
                  flex.style.setProperty('--ocr-ratio', (currentRatio * 100) + '%');
                  flex.style.setProperty('--trans-ratio', ((1 - currentRatio) * 100) + '%');
                });
              }
              applyRatioToAll();

              // 以下是旧的拖动实现，已被新的实现替代，移除以避免冲突
              /*
              let dragging = false;
              let startX = 0;
              let startRatio = ratio;
              document.querySelectorAll('.splitter').forEach(splitter => {
                splitter.onmousedown = function(e) {
                  dragging = true;
                  startX = e.clientX;
                  startRatio = ratio;
                  splitter.classList.add('active');
                  // 使用CSS类而不是直接设置样式
                  document.body.classList.add('dragging-cursor');
                  e.preventDefault();
                };
              });

              document.addEventListener('mousemove', function(e) {
                if (!dragging) return;
                const flex = document.querySelector('.align-flex');
                if (!flex) return;
                const rect = flex.getBoundingClientRect();
                let dx = e.clientX - startX;
                let newRatio = startRatio + dx / rect.width;
                newRatio = Math.max(0.3, Math.min(0.7, newRatio));
                window.chunkCompareRatio = newRatio;
                ratio = newRatio;
                applyRatioToAll();
              });

              document.addEventListener('mouseup', function() {
                if (dragging) {
                  dragging = false;
                  // 使用CSS类而不是直接设置样式
                  document.body.classList.remove('dragging-cursor');
                  document.querySelectorAll('.splitter').forEach(s => s.classList.remove('active'));
                }
              });
              */

              // 重新绑定分块对比工具栏按钮事件 - 使用CSS类管理显示模式
              document.querySelectorAll('.block-mode-btn').forEach(btn => {
                btn.onclick = function() {
                  const blockIndex = this.dataset.block;
                  const mode = this.dataset.mode;
                  window[`showMode_block_${blockIndex}`] = mode;

                  // 更新按钮激活状态
                  document.querySelectorAll(`.block-mode-btn[data-block="${blockIndex}"]`).forEach(b => {
                    b.classList.remove('active');
                  });
                  this.classList.add('active');

                  // 使用CSS类管理显示模式，而不是直接操作样式
                  document.querySelectorAll(`.block-flex-${blockIndex}`).forEach(flexPair => {
                    // 移除所有模式类
                    flexPair.classList.remove('block-mode-ocr-only', 'block-mode-trans-only', 'block-mode-both');

                    // 添加对应的模式类
                    if (mode === 'ocr') {
                      flexPair.classList.add('block-mode-ocr-only');
                    } else if (mode === 'trans') {
                      flexPair.classList.add('block-mode-trans-only');
                    } else { // mode === 'both'
                      flexPair.classList.add('block-mode-both');
                      // 当切换回 both 模式时，重新应用拖动条的比例
                      applyRatioToAllFlexPairsInBlock(blockIndex);
                    }
                  });
                };
              });

              // 辅助函数：将当前拖动比例应用到指定blockIndex的所有flexPair
              function applyRatioToAllFlexPairsInBlock(blockIndexToUpdate) {
                const currentRatio = window.chunkCompareRatio || 0.5;
                document.querySelectorAll(`.block-flex-${blockIndexToUpdate}`).forEach(flex => {
                  // 使用CSS变量
                  flex.style.setProperty('--ocr-ratio', (currentRatio * 100) + '%');
                  flex.style.setProperty('--trans-ratio', ((1 - currentRatio) * 100) + '%');
                });
              }

              // 初始化拖动比例应用到所有分块的所有对比对
              // 确保在按钮事件绑定之后，但在第一次渲染时就能正确设置
              if (document.querySelector('.align-flex')) { // 确保有可操作的元素
                const allBlockIndexes = new Set();
                document.querySelectorAll('[data-block]').forEach(el => allBlockIndexes.add(el.dataset.block));
                allBlockIndexes.forEach(idx => {
                    if(window[`showMode_block_${idx}`] === undefined || window[`showMode_block_${idx}`] === 'both') {
                        applyRatioToAllFlexPairsInBlock(idx);
                    }
                });
              }

              // 拖动分割条实现
              let draggingSplitterInfo = null; // {splitter, flexContainer, startX, initialOcrBasisPx}

              document.querySelectorAll('.splitter').forEach(splitter => {
                splitter.onmousedown = function(e) {
                  const flexContainer = e.target.closest('.align-flex');
                  if (!flexContainer) return;
                  const ocrBlock = flexContainer.querySelector('.align-block-ocr');
                  if (!ocrBlock || getComputedStyle(ocrBlock).display === 'none') return; // 只在对比模式下拖动

                  draggingSplitterInfo = {
                    splitter: e.target,
                    flexContainer: flexContainer,
                    startX: e.clientX,
                    initialOcrBasisPx: ocrBlock.offsetWidth
                  };

                  e.target.classList.add('active');
                  // 使用CSS类而不是直接设置样式
                  document.body.classList.add('dragging-cursor');
                  e.preventDefault();
                };
              });

              document.addEventListener('mousemove', function(e) {
                if (!draggingSplitterInfo) return;

                const { splitter, flexContainer, startX, initialOcrBasisPx } = draggingSplitterInfo;
                const ocrBlock = flexContainer.querySelector('.align-block-ocr');
                const transBlock = flexContainer.querySelector('.align-block-trans');
                if (!ocrBlock || !transBlock) return;

                const dx = e.clientX - startX;
                const containerWidth = flexContainer.offsetWidth;
                if (containerWidth === 0) return;

                let newOcrWidthPx = initialOcrBasisPx + dx;
                // 限制最小/最大宽度，例如总宽度的20%到80%
                const minWidthPx = containerWidth * 0.2;
                const maxWidthPx = containerWidth * 0.8;
                newOcrWidthPx = Math.max(minWidthPx, Math.min(newOcrWidthPx, maxWidthPx));

                const newOcrRatio = newOcrWidthPx / containerWidth;

                // 更新当前拖动的块的比例
                flexContainer.style.setProperty('--ocr-ratio', (newOcrRatio * 100) + '%');
                flexContainer.style.setProperty('--trans-ratio', ((1 - newOcrRatio) * 100) + '%');

                // 更新全局比例，以便新加载的块或切换回对比模式时使用
                window.chunkCompareRatio = newOcrRatio;

                // 调用applyRatioToAll()使所有其他块的比例联动
                // 但排除当前正在拖动的块，避免视觉抖动
                document.querySelectorAll('.align-flex').forEach(flex => {
                  if (flex !== flexContainer) {
                    flex.style.setProperty('--ocr-ratio', (newOcrRatio * 100) + '%');
                    flex.style.setProperty('--trans-ratio', ((1 - newOcrRatio) * 100) + '%');
                  }
                });
              });

              document.addEventListener('mouseup', function() {
                if (draggingSplitterInfo) {
                  draggingSplitterInfo.splitter.classList.remove('active');
                  draggingSplitterInfo = null;
                  // 使用CSS类而不是直接设置样式
                  document.body.classList.remove('dragging-cursor');

                  // 不再需要调用applyRatioToAll，因为在mousemove中已经应用了比例
                  // if (typeof window.chunkCompareRatio === 'number') {
                  //   applyRatioToAll();
                  // }

                  // 持久化当前的比例设置到localStorage
                  if (docIdForLocalStorage && typeof window.chunkCompareRatio === 'number') {
                    localStorage.setItem(`chunkCompareRatio_${docIdForLocalStorage}`, window.chunkCompareRatio.toString());
                  }
                }
              });

              document.querySelectorAll('.block-copy-btn').forEach(btn => {
                btn.onclick = function() {
                  const blockIndex = this.dataset.block;
                  const rawBlockContent = window[`blockRawContent_${blockIndex}`];
                  const currentMode = window[`showMode_block_${blockIndex}`] || 'both'; // 获取当前模式

                  if (rawBlockContent && Array.isArray(rawBlockContent)) {
                    let textToCopy = "";
                    let alertMessage = "";

                    if (currentMode === 'ocr') {
                      rawBlockContent.forEach(pair => {
                        // 如果原文在左，pair[0]是原文；如果译文在左，pair[0]是译文
                        const ocrText = isOriginalFirstInChunkCompare ? (pair && pair[0]) : (pair && pair[1]);
                        if (ocrText) textToCopy += ocrText + "\n\n";
                      });
                      textToCopy = textToCopy.trim();
                      alertMessage = `第 ${parseInt(blockIndex) + 1} 块的 原文 已复制!`;
                    } else if (currentMode === 'trans') {
                      rawBlockContent.forEach(pair => {
                        // 如果原文在左，pair[1]是译文；如果译文在左，pair[1]是原文
                        const transText = isOriginalFirstInChunkCompare ? (pair && pair[1]) : (pair && pair[0]);
                        if (transText) textToCopy += transText + "\n\n";
                      });
                      textToCopy = textToCopy.trim();
                      alertMessage = `第 ${parseInt(blockIndex) + 1} 块的 译文 已复制!`;
                    } else { // mode === 'both'
                      rawBlockContent.forEach(pair => {
                        const ocrText = isOriginalFirstInChunkCompare ? (pair && pair[0]) : (pair && pair[1]);
                        const transText = isOriginalFirstInChunkCompare ? (pair && pair[1]) : (pair && pair[0]);
                        if (ocrText) textToCopy += "原文:\n" + ocrText + "\n\n";
                        if (transText) textToCopy += "译文:\n" + transText + "\n\n";
                      });
                      textToCopy = textToCopy.trim();
                      alertMessage = `第 ${parseInt(blockIndex) + 1} 块的 原文和译文 已复制!`;
                    }

                    if (textToCopy) {
                      navigator.clipboard.writeText(textToCopy)
                        .then(() => alert(alertMessage))
                        .catch(err => {
                          console.error('复制失败:', err);
                          alert('复制失败，请查看控制台。');
                        });
                    } else {
                      alert('没有内容可复制。');
                    }
                  }
                };
              });

              document.querySelectorAll('.block-struct-copy-btn').forEach(btn => {
                btn.onclick = function() {
                  const blockIndex = this.dataset.block;
                  const type = this.dataset.type; // 'ocr' or 'trans'
                  const structIdx = parseInt(this.dataset.idx);
                  const rawBlockContent = window[`blockRawContent_${blockIndex}`];
                  if (rawBlockContent && rawBlockContent[structIdx]) {
                    const textToCopy = (type === 'ocr') ? rawBlockContent[structIdx][0] : rawBlockContent[structIdx][1];
                    navigator.clipboard.writeText(textToCopy)
                      .then(() => alert(`第 ${parseInt(blockIndex) + 1} 块的 ${type === 'ocr' ? '原文' : '译文'} (结构 ${structIdx + 1}) 已复制!`))
                      .catch(err => console.error('复制失败:', err));
                  }
                };
              });

              document.querySelectorAll('.block-nav-btn').forEach(btn => {
                btn.onclick = function() {
                  const blockIndex = parseInt(this.dataset.block);
                  const direction = this.dataset.dir;
                  let targetIndex = direction === 'prev' ? blockIndex - 1 : blockIndex + 1;
                  const targetElement = document.getElementById(`block-${targetIndex}`);
                  if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // 可选：添加高亮效果
                    targetElement.classList.add('block-highlight');
                    setTimeout(() => targetElement.classList.remove('block-highlight'), 1500);
                  }
                };
              });

            }, 0);
        } else {
            html = '<h3>分块对比</h3><p>此记录没有有效的分块对比数据。</p>';
            if (!data.ocrChunks || !data.translatedChunks) {
                 html += '<p>原因：缺少分块数据 (ocrChunks or translatedChunks missing)。</p>';
            } else if (data.ocrChunks.length !== data.translatedChunks.length) {
                 html += `<p>原因：原文块数量 (${data.ocrChunks.length}) 与译文块数量 (${data.translatedChunks.length}) 不匹配。</p>`;
            } else {
                 html += '<p>原因：分块数据为空。</p>';
            }
        }
      }
      document.getElementById('tabContent').innerHTML = html;

      // NEW: Adjust long headings. This should be called AFTER innerHTML is set
      // and BEFORE refreshTocList is called.
      const tabContentElement = document.getElementById('tabContent');
      if (tabContentElement) {
          adjustLongHeadingsToParagraphs(tabContentElement);
      }

      if (typeof window.refreshTocList === 'function') {
        window.refreshTocList(); // 更新TOC
      }

      // Update reading progress when tab changes and content is rendered - CALLING DOCK_LOGIC
      if (window.DockLogic && typeof window.DockLogic.forceUpdateReadingProgress === 'function') {
        window.DockLogic.forceUpdateReadingProgress();
      }

      // 如果是分块对比视图，并且按钮存在，则绑定事件
      if (tab === 'chunk-compare') {
        const swapBtn = document.getElementById('swap-chunks-btn');
        if (swapBtn) {
            swapBtn.onclick = function() {
                isOriginalFirstInChunkCompare = !isOriginalFirstInChunkCompare;
                showTab('chunk-compare'); // 重新渲染分块对比视图
            };
        }
      }

      // After tab content is updated, refresh chatbot UI if it's open
      if (window.isChatbotOpen && typeof window.ChatbotUI !== 'undefined' && typeof window.ChatbotUI.updateChatbotUI === 'function') {
        window.ChatbotUI.updateChatbotUI();
      }

      // 应用高亮和批注
      if ((tab === 'ocr' || tab === 'translation') && contentContainerId) {
        activeContentElement = document.getElementById(contentContainerId);
        if (activeContentElement) {
            const directChildNodes = Array.from(activeContentElement.children);
            const blockElements = directChildNodes.filter(node =>
                node.nodeType === Node.ELEMENT_NODE && true
            );
            blockElements.forEach((element, index) => {
                element.dataset.blockIndex = String(index);
                // MODIFIED to use SubBlockSegmenter
                if (typeof window.SubBlockSegmenter !== 'undefined' && typeof window.SubBlockSegmenter.segment === 'function') {
                    window.SubBlockSegmenter.segment(element, index);
                } else {
                    console.error("SubBlockSegmenter.segment is not available.");
                }
            });

            if (data && data.annotations) {
                if (typeof window.applyBlockAnnotations === 'function') {
                    console.log(`[showTab] 为 ${window.globalCurrentContentIdentifier} 调用块级批注应用函数 (操作对象将是子块)`);
                    window.applyBlockAnnotations(activeContentElement, data.annotations, window.globalCurrentContentIdentifier);
                } else {
                    console.warn("[showTab] 块级/子块批注应用函数 (applyBlockAnnotations) 未定义。请检查 js/annotation_highlighter.js");
                }
            }
        }
        if (typeof window.addAnnotationListenersToContainer === 'function') {
            // 为 OCR 和 Translation 视图传递当前的全局内容标识符
            window.addAnnotationListenersToContainer(contentContainerId, window.globalCurrentContentIdentifier);
        } else {
            console.error("addAnnotationListenersToContainer 未定义。请检查 js/annotation_logic.js");
        }
      } else if (tab === 'chunk-compare') {
         // 对于分块对比视图，为每个原文和译文块单独处理
         setTimeout(() => { //确保DOM更新完毕
            const ocrContentAreas = document.querySelectorAll('.chunk-compare-container .align-block-ocr .align-content.markdown-body');
            const transContentAreas = document.querySelectorAll('.chunk-compare-container .align-block-trans .align-content.markdown-body');

            function processContentArea(area, isOcrArea) {
                if (!area.id) {
                    area.id = 'chunk-content-' + _page_generateUUID();
                }
                const effectiveContentIdentifier = isOriginalFirstInChunkCompare ? (isOcrArea ? 'ocr' : 'translation') : (isOcrArea ? 'translation' : 'ocr');

                // 1. 分割子块
                const directChildNodes = Array.from(area.children);
                const blockElements = directChildNodes.filter(node => node.nodeType === Node.ELEMENT_NODE);
                blockElements.forEach((element, index) => {
                    element.dataset.blockIndex = String(index); // 为每个块内元素设置独立的 blockIndex
                    // MODIFIED to use SubBlockSegmenter
                    if (typeof window.SubBlockSegmenter !== 'undefined' && typeof window.SubBlockSegmenter.segment === 'function') {
                        window.SubBlockSegmenter.segment(element, index);
                    } else {
                        console.error("SubBlockSegmenter.segment is not available for chunk processing.");
                    }
                });

                // 2. 应用批注
                if (data && data.annotations && typeof window.applyBlockAnnotations === 'function') {
                    // console.log(`[showTab ChunkCompare] 为 ${area.id} (类型: ${effectiveContentIdentifier}) 应用批注`);
                    // MODIFIED: Pass empty array for annotations in chunk-compare mode
                    const annotationsToApply = (currentVisibleTabId === 'chunk-compare') ? [] : data.annotations;
                    window.applyBlockAnnotations(area, annotationsToApply, effectiveContentIdentifier);
                }

                // 3. 添加监听器
                if (typeof window.addAnnotationListenersToContainer === 'function') {
                    // console.log(`[showTab ChunkCompare] 为 ${area.id} (类型: ${effectiveContentIdentifier}) 添加监听器`);
                    window.addAnnotationListenersToContainer(area.id, effectiveContentIdentifier);
                }
            }

            ocrContentAreas.forEach(area => processContentArea(area, true));
            transContentAreas.forEach(area => processContentArea(area, false));

         }, 0);
      }

      // Attempt to restore scroll position for the current tab
      if (docIdForLocalStorage && currentVisibleTabId) {
        const scrollKey = `scrollPos_${docIdForLocalStorage}_${currentVisibleTabId}`;
        const savedScrollTop = localStorage.getItem(scrollKey);
        // console.log(`[showTab] Attempting to restore scroll for ${scrollKey} on documentElement. Saved value: ${savedScrollTop}`);
        if (savedScrollTop !== null && !isNaN(parseInt(savedScrollTop, 10))) {
          const scrollableElement = document.documentElement; // Changed from .container
          if (scrollableElement) {
            requestAnimationFrame(() => {
              if(currentVisibleTabId === tab) { // Ensure tab hasn't changed during async operation
                scrollableElement.scrollTop = parseInt(savedScrollTop, 10);
                // console.log(`[showTab] Restored scroll for ${scrollKey} (tab: ${tab}) on documentElement to ${scrollableElement.scrollTop}`);
              }
            });
          }
        }
      }
      // Call updateReadingProgress after potential scroll restoration and content rendering - CALLING DOCK_LOGIC
      if (window.DockLogic && typeof window.DockLogic.forceUpdateReadingProgress === 'function') {
        window.DockLogic.forceUpdateReadingProgress();
      }
      // updateAllDockStats(); // Update all dock stats after tab content is fully processed - CALLING DOCK_LOGIC
      if (window.DockLogic && typeof window.DockLogic.updateStats === 'function') {
        window.DockLogic.updateStats(window.data, currentVisibleTabId);
      }
    }
    // 绑定tab按钮点击事件
    document.getElementById('tab-ocr').onclick = function() { showTab('ocr'); };
    document.getElementById('tab-translation').onclick = function() { showTab('translation'); };
    // document.getElementById('tab-compare').onclick = function() { showTab('compare'); }; // 点击事件注释掉
    document.getElementById('tab-chunk-compare').onclick = function() { showTab('chunk-compare'); };

    // 页面加载后渲染详情
    renderDetail();

    /**
     * 将批注应用到指定的内容容器上。
     * @param {HTMLElement} containerElement - 内容的DOM容器 (例如包含OCR或翻译文本的div)。
     * @param {Array<Object>} annotations - 当前文档的批注对象数组。
     * @param {string} contentIdentifier - 内容类型标识符 (例如 'ocr', 'translation')。
     */
    // MOVED to js/annotation_logic.js: function applyAnnotationsToContent(...) {...}

    // ==========================
    // 自定义上下文菜单逻辑 -- MOVED to js/annotation_logic.js
    // ==========================
    // const contextMenu = document.getElementById('custom-context-menu'); // Will be handled by annotation_logic.js

    // MOVED to js/annotation_logic.js: function fuzzyMatch(...) {...}
    // MOVED to js/annotation_logic.js: function checkIfTextIsHighlighted(...) {...}
    // MOVED to js/annotation_logic.js: function checkIfTextHasNote(...) {...}
    // MOVED to js/annotation_logic.js: function updateContextMenuOptions(...) {...}
    // MOVED to js/annotation_logic.js: function showContextMenu(...) {...}
    // MOVED to js/annotation_logic.js: function hideContextMenu(...) {...}
    // MOVED to js/annotation_logic.js: function addContextMenuListener(...) {...} // Renamed to addAnnotationListenersToContainer
    // MOVED to js/annotation_logic.js: contextMenu.addEventListener('click', async (event) => {...});
    // MOVED to js/annotation_logic.js: document.addEventListener('click', (event) => {...});
    // MOVED to js/annotation_logic.js: function _page_generateUUID() {...}

    /**
     * @namespace TocFeature
     * @description 管理页面右侧浮动的目录 (Table of Contents) 功能。
     * 包括TOC按钮的点击事件、TOC悬浮窗的显示/隐藏、
     * 以及动态生成TOC列表项。
     */
    // MOVED to js/toc_logic.js: (function TocFeature(){...})();

    /**
     * 监听 localStorage 的 `storage` 事件。
     * 如果 `paperBurnerSettings` 发生变化（通常在主页面修改设置导致），
     * 尝试更新聊天机器人 (Chatbot) 的配置或UI（如果相关模块已加载并可用）。
     * @param {StorageEvent} e - storage 事件对象。
     */
    window.addEventListener('storage', function(e) {
      if (e.key === 'paperBurnerSettings') {
        // 重新加载设置并刷新 chatbot 配置
        if (window.ChatbotCore && typeof window.ChatbotCore.getChatbotConfig === 'function') {
          // 你可以强制刷新 Chatbot UI 或重载配置
          window.ChatbotUI && window.ChatbotUI.updateChatbotUI && window.ChatbotUI.updateChatbotUI();
        }
      }
    });

    /**
     * 将 exact 文本转为模糊正则，允许空格、换行模糊匹配，大小写不敏感
     * @param {string} exact
     * @returns {RegExp}
     */
    function escapeRegExp(string) {
      // 更安全地转义所有正则特殊字符
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    function fuzzyRegFromExact(exact) {
      // 先转义所有正则特殊字符
      let pattern = escapeRegExp(exact);
      // 将所有空白替换为 \s+，允许跨行、多个空格
      pattern = pattern.replace(/\s+/g, '\\s+');
      // 可选：忽略前后空白
      pattern = '\\s*' + pattern + '\\s*';
      return new RegExp(pattern, 'gi');
    }

    // function highlightTextWithAnnotations(text, annotations, contentIdentifier) { // Obsolete due to block based.
    //   console.warn('[highlightTextWithAnnotations] This function is part of the old text-based highlighting system and should ideally be phased out.');
    //   if (!annotations || !Array.isArray(annotations) || !text) return text;
    //   // 只处理当前内容类型的高亮
    //   const relevant = annotations.filter(
    //     ann =>
    //       ann.targetType === contentIdentifier &&
    //       ann.target &&
    //       Array.isArray(ann.target.selector) &&
    //       ann.target.selector[0] &&
    //       ann.target.selector[0].exact
    //   );
    //   if (relevant.length === 0) return text;

    //   // 按照 exact 长度降序排序，避免嵌套覆盖
    //   relevant.sort((a, b) => (b.target.selector[0].exact.length - a.target.selector[0].exact.length));

    //   let result = text;
    //   relevant.forEach(ann => {
    //     const color = ann.highlightColor || 'yellow';
    //     const note = ann.body && ann.body.length > 0 && ann.body[0].value ? ann.body[0].value : '';
    //     const exact = ann.target.selector[0].exact;
    //     const reg = fuzzyRegFromExact(exact);
    //     result = result.replace(
    //       reg,
    //       `<mark class="annotation-highlight" style="background:${color}" title="${note.replace(/"/g, '&quot;')}">$&</mark>`
    //     );
    //   });
    //   return result;
    // }

    /**
     * 从数据库中移除指定文本的高亮批注
     * @param {string} selectedText - 要取消高亮的文本
     * @param {string} docId - 文档ID
     */
    // MOVED to js/annotation_logic.js: async function removeHighlightFromText(selectedText, docId) {...}

    /**
     * 为现有的高亮文本添加批注
     * @param {string} selectedText - 选中的文本
     * @param {string} noteText - 批注内容
     * @param {string} docId - 文档ID
     */
    // MOVED to js/annotation_logic.js: async function addNoteToExistingHighlight(selectedText, noteText, docId) {...}

    // Dock Settings Modal Logic
    // MOVED to js/dock_settings_modal.js

    // Annotations/Highlights Summary Modal Logic
    // MOVED to js/annotations_summary_modal.js
  </script>

</body>
</html>